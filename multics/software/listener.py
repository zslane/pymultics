import datetime

from ..globals import *

include.query_info

class Listener(SystemSubroutine):

    def __init__(self, supervisor, command_processor):
        super(Listener, self).__init__(self.__class__.__name__, supervisor)
        
        self.supervisor = supervisor
        self.__default_command_processor = command_processor
        self.__process = None
        self.__prev_command_time = None
        self.__command_history = []
        self.__homedir = ""
        self.exit_code = 0
        
    def start(self, owning_process):
        self.__process = owning_process
        return self._main_loop()
        
    def kill(self):
        self._cleanup()
        
    def ready(self, ready_mode):
        if ready_mode:
            now = datetime.datetime.now()
            delta, self.__prev_command_time = now - self.__prev_command_time, now
            
            ready_message = "r %s %0.3f %d" % (now.strftime("%H%M"), delta.seconds + (delta.microseconds / 10.0**6), call.segfault_count)
            call.ioa_(ready_message)
    
    def _main_loop(self):
        command_line = parm()
        code         = parm()
        
        query_info.suppress_name_sw = True
        query_info.suppress_spacing = True
        
        self._initialize()
        
        if not self.__process.pit().no_start_up:
            call.cu_.cp("exec_com start_up new_proc interactive", code)
        # end if
        
        self.exit_code = 0
        while self.exit_code == 0:
            try:
                call.cu_.ready_proc()
                call.command_query_(query_info, command_line, "listener")
                self.__command_history.append(command_line.val)
                call.cu_.cp(command_line.val, code)
                self.exit_code = code.val
                
            except BreakCondition:
                call.hcs_.signal_break()
            except DisconnectCondition:
                self.exit_code = System.LOGOUT
            except ShutdownCondition:
                self.exit_code = System.LOGOUT
            except (SegmentFault, LinkageError, InvalidSegmentFault):
                call.dump_traceback_()
            except:
                #== FOR DEBUGGING THE SIMULATION
                call.dump_traceback_()
            # end try
        # end while
        
        # do any cleanup necessary at the CommandShell level
        self._cleanup()
        
        return self.exit_code
            
    def _on_condition__break(self):
        pass
        
    def _initialize(self):
        homedir = parm()
        call.user_info_.homedir(homedir)
        call.sys_.push_directory(homedir.val)
        call.cu_.set_command_processor(self.__default_command_processor)
        call.cu_.set_ready_procedure(self.ready)
        call.cu_.set_ready_mode(True)
        self.__homedir = homedir.val
        self.__prev_command_time = datetime.datetime.now()
        
        msg_handlers = {
            'interactive_message':   self._interactive_message_handler,
            'shutdown_announcement': self._interactive_message_handler,
            'shutdown':              self._shutdown_handler,
        }
        self.__process.register_msg_handlers(msg_handlers)
        
    def _interactive_message_handler(self, message):
        call.sys_.recv_message_(message)
    
    def _shutdown_handler(self, message):
        print get_calling_process_().objectName() + " invoking _shutdown_handler"
        #== If the system is already in shutdown state (i.e., shutdown was initiated
        #== by this process), then signal_shutdown() does nothing. If not (i.e., this
        #== process is receiving shutdown messages generated by another user's process),
        #== then signal_shutdown() will cause the necessary shutdown to occur.
        call.sys_.signal_shutdown()
    
    def _cleanup(self):
        pass
        