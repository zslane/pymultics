
starrunners: star: procedure options (variable);

          dcl       ioa_                          entry options (variable);
          dcl       ioa_$nnl                      entry options (variable);
          dcl       getline                       entry options (variable);
          dcl       do                            entry options (variable);
          
          dcl       hcs_$make_seg                 entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
          dcl       hcs_$initiate                 entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
          dcl       hcs_$delentry_seg             entry (ptr, fixed bin (35));
          dcl       hcs_$set_ring_brackets        entry (char (*), char (*), (3) fixed bin (3), fixed bin (35));
          
          dcl       timer_manager_$alarm_call     entry (fixed bin (71), bit (2), entry);
          dcl       timer_manager_$reset_alarm_call entry (entry);
          
          dcl       get_pdir_                     entry returns (char (168));
          dcl       pdir                          char (32) init ("");
          dcl       edir                          char (32) init ("");
          
          dcl       set_acl                       entry (char (*), char (*), char (*));
          dcl       entry                         char (45) init ("");
          dcl       acl                           char (2) init ("rw");
          dcl       whom                          char (5) init ("*.*.*");
          
          dcl       print                         entry (char (*), char (*));
          dcl       helpfile                      char (25) init (">udd>sct>game>s>star.help");
          
          dcl       read_password_                entry (char (*), char (*));
          
          dcl       com_err_                      entry options (variable);
          dcl       MAIN                          char (11) init ("starrunners");
          dcl       version                       char (5) init ("4.4");
          
          dcl       user_info_$whoami             entry (char (*), char (*), char (*));
          dcl       person                        char (32) init ("");
          dcl       project                       char (9) init ("");
          dcl       access                        char (3) init ("no");
          
          dcl       term_$single_refname          entry (char (*) aligned, fixed bin (35));
          dcl       DO_dir                        char (4) init (">sss");
          dcl       DO                            char (2) init ("do");
          
          dcl       cu_$arg_count                 entry (fixed bin, fixed bin (35));
          dcl       cu_$arg_ptr                   entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
          dcl       argn                          fixed bin init (0);
          dcl       argp                          ptr init (null ());
          dcl       argl                          fixed bin (21) init (0);
          dcl       arg                           char (argl) based (argp);
          
          dcl       input                         char (256) varying init ("");
          dcl       shiptype                      char (14) init ("");
          dcl       dname                         char (14) init (">udd>sct>g>dbd");
          dcl       ename                         char (10) init ("sv4.4.ship");
          dcl       xname                         char (10) init ("sv4.4.univ");
          dcl       aname                         char (10) init ("sv1.2.info");
          dcl       ring_brackets                 (3) fixed bin (3) init (5, 5, 5);
          dcl       code                          fixed bin (35) init (0);
          dcl       allowed_chars                 char (87) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !$%&'()*:=-[]{}<>.,/?_|^");
          dcl       enter_admin_loop              bit (1) init ("0"b);
          dcl       video_mode                    bit (1) init ("0"b);
          dcl       accept_notifications          bit (1) init ("0"b);
          dcl       on_the_list                   bit (1) init ("0"b);
          dcl       list_players                  bit (1) init ("0"b);
          dcl       target                        char (10) init ("");
          dcl       (x, y, z)                     fixed bin init (0);
          
          dcl       (univptr, my, enemy, adminptr) internal static ptr init (null ());
          
          dcl       1 admin_info                  aligned based (adminptr),
                      2 game_admin                char (21),
                      2 user_info_line            char (30),
                      2 com_query_line            char (30),
                      2 star_comn                 fixed bin,
                      2 star_coms                 (admin_info.star_comn) char (21);
                      
          dcl       1 universe                    aligned based (univptr),
                      2 number                    fixed bin,
                      2 pdir                      (10) char (32),
                      2 user                      (10) char (21),
                      2 unique_id                 (10) fixed bin,
                      2 holes                     fixed bin,
                      2 black_hole                (5) char (8),
                      2 password                  char (10),
                      2 robot                     (20),
                        3 name                    char (5),
                        3 energy                  fixed bin,
                        3 condition               char (7),
                        3 location                char (8),
                        3 controller              char (21),
                      2 notifications             (50),
                        3 person_id               char (21),
                        3 project_id              char (9),
                      2 lock                      bit (36);
                      
          dcl       1 ship                        aligned based,
                      2 user                      char (32),
                      2 unique_id                 fixed bin,
                      2 name                      char (10),
                      2 type                      char (14),
                      2 energy_cur                fixed bin,
                      2 energy_old                fixed bin,
                      2 energy_max                fixed bin,
                      2 shields_cur               fixed bin,
                      2 shields_old               fixed bin,
                      2 shields_max               fixed bin,
                      2 torps_cur                 fixed bin,
                      2 torps_old                 fixed bin,
                      2 torps_max                 fixed bin,
                      2 life_cur                  fixed bin,
                      2 life_old                  fixed bin,
                      2 condition                 char (12),
                      2 location                  char (8),
                      2 message                   char (256),
                      2 fromname                  char (10),
                      2 fromtype                  char (14),
                      2 deathmes                  char (4),
                      2 deadname                  char (10),
                      2 deadtype                  char (14),
                      2 cloak_on                  bit (1),
                      2 tractor_on                bit (1),
                      2 tracname                  char (10),
                      2 monitored_by              char (10),
                      2 monname                   char (10),
                      2 montype                   char (14),
                      2 monloc                    char (8),
                      2 black_hole                char (8),
                      2 psionics                  bit (1),
                      2 psi_num                   fixed bin,
                      2 psi_name                  (0: 10) char (10),
                      2 psi_type                  (0: 10) char (14),
                      2 psi_mes                   (0: 10) char (8),
                      2 lock                      bit (36);
                      
          dcl       continue_to_signal_           entry (fixed bin (35));
          dcl       quit                          condition;
          dcl       seg_fault_error               condition;
          dcl       finish                        condition;

/***** LET'S GET THE SHOW ON THE ROAD -- PRELIMINARY STUFF *****/

/* SET GAME MODES: -admin, -video, -list_players CONTROL_ARGS */
          call cu_$arg_count (argn, code);
          if code ^= 0 then do;
                    call com_err_ (code, MAIN);
                    return;
               end;
          do x = 1 to argn;
               call cu_$arg_ptr (x, argp, argl, code);
               if arg = "-admin" then enter_admin_loop = "1"b;
               else if arg = "-video" then video_mode = "1"b;
               else if arg = "-list_players" | arg = "-lp" then list_players = "1"b;
               else if arg = "-accept_notifications" | arg = "-ant" then accept_notifications = "1"b;
               else if arg = "-refuse_notifications" | arg = "-rnt" then accept_notifications = "0"b;
               else if substr (arg, 1, 1) = "-" then do;
                         call ioa_ ("^a: Specified control argument is not accepted. ^a", MAIN, arg);
                         return;
                    end;
          end;
          
/* ENTER ADMIN LOOP IF -admin CONTROL_ARG WAS SUPPLIED, AND USER HAS ACCESS */
          call term_$single_refname ((DO), code);
          call hcs_$initiate (DO_dir, DO, DO, 0, 0, (null ()), code);
          call hcs_$initiate (dname, aname, "", 0, 0, adminptr, code);
          if code ^= 0 & adminptr = null () then do;
                    call ioa_ ("^/Administrative matrix not found.  Game locked.");
                    return;
               end;
          call do (admin_info.user_info_line);
          call do (admin_info.com_query_line);
          call hcs_$initiate ((get_pdir_ ()), "pit", "", 0, 0, pit_ptr, code);
          person = pit.login_name;
          project = pit.project;
          if enter_admin_loop then do;
                    if person = admin_info.game_admin then do;
                              call star_admin;
                              return;
                         end;
                    else do;
                              call ioa_ ("This command is for Starrunners Administrators only.");
                              return;
                         end;
               end;
               
/* SET UP GAME ENVIRONMENT */
          call ioa_ ("^/Starrunners ^a", version);
          do x = 1 to admin_info.star_comn;
               if person = admin_info.star_coms (x) then access = "yes";
          end;
          call hcs_$initiate (dname, xname, "", 0, 0, univptr, code);
          if code ^= 0 & univptr = null () then do;
                    call ioa_ ("^/I'm sorry, but the STARRUNNERS universe is closed.^/Please feel free to try later.  Thank you...");
                    return;
               end;
          if universe.number = 10 then do;
                    call ioa_ ("^/I'm sorry, but the STARRUNNERS universe is filled to maximum capacity.^/Please feel free to try later.  Thank you...");
                    return;
               end;
               
/* ACCEPT/REFUSE NOTIFICATIONS.  PUT/TAKE ON/FROM LIST */
          do x = 1 to 50;
               if universe.notifications (x).person_id = person & universe.notifications (x).project_id = project then do;
                         if ^accept_notifications then do;
                                   universe.notifications (x).person_id = "";
                                   universe.notifications (x).project_id = "";
                              end;
                         on_the_list = "1"b;
                    end;
          end;
          if ^on_the_list & accept_notifications then do;
                    do x = 1 to 50;
                         if universe.notifications (x).person_id = "" & universe.notifications (x).project_id = "" then do;
                                   universe.notifications (x).person_id = person;
                                   universe.notifications (x).project = project;
                                   return;
                              end;
                    end;
               end;
          if ^on_the_list & accept_notifications then call ioa_ ("^/Sorry, but the notifications list is full to maximum capacity...");
          if on_the_list then return;
          
/* IF -list_players CONTROL_ARG WAS SUPPLIED, LIST PLAYERS, NO GAME */
          if list_players then do;
                    call ioa_ ("^/List of players: ^[none^]^[^d^]", (universe.number = 0), (universe.number > 0), universe.number);
                    do x = 1 to universe.number;
                         call ioa_ ("^3x^a", universe.user (x));
                    end;
                    return;
               end;
               
/* ASK HIM IF HE WANTS INSTRUCTIONS */
          do while (input = "");
               call ioa_$nnl ("^/Would you like instructions? ");
               call getline (input);
               if input = "yes" | input = "y" then call print (helpfile, "1");
               else if input ^= "no" & input ^= "n" then do;
                         call ioa_ ("^/Please answer ""yes"" or ""no"".");
                         input = "";
                    end;
          end;
          
/* GET GAME PASSWORD (IF THERE IS ONE) */
          if universe.password ^= "" then do;
                    call ioa_$nnl ("^/Password: ");
                    call getline (input);
                    if input ^= universe.password then do;
                              call ioa_ ("Incorrect password supplied.");
                              call ioa_ ("Please contact Starrunners Administrator for correct password.");
                              return;
                         end;
               end;
               
/* SET quit AND seg_fault_error TO DESTROY SHIP/END GAME */
          on quit call game_over;
          on seg_fault_error call universe_destroyed;
          
/* SET finish TO TURN OFF NOTIFICATIONS */
          on finish begin;
                    do x = 1 to 50;
                         if universe.notifications (x).person_id = person & universe.notifications (x).project_id = project then do;
                                   universe.notifications (x).person_id = "";
                                   universe.notifications (x).project_id = "";
                              end;
                    end;
                    call continue_to_signal_ ((0));
               end;
               
/* MAKE HIS SHIP */
          pdir = get_pdir_ ();
          call hcs_$initiate(pdir, ename, "", 0, 0, my, code);
          if my ^= null () then call hcs_$delentry_seg (my, code);
          call hcs_$make_seg (pdir, ename, "", (10), my, code);
          entry = pdir || ">" || ename;
          call set_acl (entry, acl, whom);
          call hcs_$set_ring_brackets (pdir, ename, ring_brackets, code);
          if code ^= 0 then do;
                    call com_err_ (code, MAIN);
                    return;
               end;
               
/* CLEAN OUT SHIP DATA FOR A FRESH START */
          call lock (my -> ship.lock);
          my -> ship.user, my -> ship.name, my -> ship.type, my -> ship.condition, my -> ship.message, my -> ship.fromname, my -> ship.fromtype, my -> ship.deathmes, my -> ship.deadname, my -> ship.deadtype, my -> ship.tracname, my -> ship.monitored_by, my -> ship.monloc, my -> ship.psi_name, my -> ship.psi_type, my -> ship.psi_mes = "";
          my -> ship.monname, my -> ship.montype = "#";
          my -> ship.location = "PHASING";
          my -> ship.black_hole = "start";
          my -> ship.energy_cur, my -> ship.energy_old, my -> ship.energy_max, my -> ship.shields_cur, my -> ship.shields_old, my -> ship.shields_max, my -> ship.torps_cur, my -> ship.torps_old, my -> ship.torps_max, my -> ship.life_cur, my -> ship.life_old, my -> ship.psi_num = 0;
          my -> ship.cloak_on, my -> ship.tractor_on, my -> ship.psionics = "0"b;
          my -> ship.unique_id = clock ();
          call unlock (my -> ship.lock);
          
/* ADD HIM TO LIST OF PLAYERS IN THE STARRUNNERS UNIVERSE */
          if universe.number = 10 then do;
                    call ioa_ ("I'm sorry, but the STARRUNNERS universe if filled to maximum capacity.^/Please feel free to try later.  Thank you...");
                    return;
               end;
          call lock (universe.lock);
          universe.number = universe.number + 1;
          universe.pdir (universe.number) = pdir;
          universe.unique_id (universe.number) = my -> ship.unique_id;
          universe.user (universe.number) = person;
          if universe.number = 1 then do;
                    universe.holes = 0;
                    universe.black_hole = "";
                    universe.robot (*).energy = 0;
                    universe.robot (*).location = "";
                    universe.robot (*).condition = "";
                    universe.robot (*).controller = "none";
               end;
          call unlock (universe.lock);
          
/* RECORED THE USER'S PERSON_ID */
          call lock (my -> ship.lock);
          my -> ship.user = person;
          call unlock (my -> ship.lock);
          
/* GET SHIP NAME */
          input = "";
          do while (input = "");
               call ioa_$nnl ("^/Ship name: ");
               call getline (input);
               if verify (input, allowed_chars) ^= 0 then do;
                         call ioa_ ("Invalid ship name: ^a", input);
                         input = "";
                    end;
               do x = 1 to universe.number;
                    edir = universe.pdir (x);
                    call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
                    if enemy ^= null () & edir ^= pdir & input = enemy -> ship.name then do;
                              call ioa_ ("^/The name you have chosen is presently in use.^/Please choose a different name.");
                              input = "";
                         end;
               end;
               if input ^= "" then my -> ship.name = input;
          end;
          
/* GET SHIP TYPE */
          input = "";
          do while (input = "");
               call ioa_$nnl ("Ship type: ");
               call getline (input);
               if input = "Destroyer" | input = "D" then shiptype = "Destroyer";
               else if input = "Cruiser" | input = "C" then shiptype = "Cruiser";
               else if input = "Starship" | input = "S" then shiptype = "Starship";
               else if input = "Star Commander" | input = "SC" then do;
                         if access ^= "yes" then do;
                                   call ioa_ ("^/You do not have proper clearance for Star Command.^/");
                                   input = "";
                              end;
                         else do;
                                   call ioa_ ();
                                   call read_password_ ("Password: ", shiptype);
                                   if length (ltrim (rtrim (shiptype))) < 3 then do;
                                             call ioa_ ("^a: Password must be at least 3 characters long.", MAIN);
                                             return;
                                        end;
                                   call read_password_ ("Codeword:", target);
                                   if target ^= generate_codeword (shiptype) then do;
                                             call ioa_ ("Star Command clearance check failed.^/");
                                             input = "";
                                        end;
                                   else call ioa_ ("^/You have been cleared for Star Command.");
                                   shiptype = "Star Commander";
                              end;
                    end;
               else do;
                         call ioa_ ("That is not a standard ship type ---> use: Destroyer, Cruiser, or Starship.");
                         input = "";
                    end;
          end;
          
/* FINAL SET-UP PREPARATIONS */
          call make_ship (shiptype);
          call ship_status;
          call black_hole_check;
          call check_monitor;
          call send_notifications;

/***** ENTER COMMAND LOOP ENVIRONMENT *****/

command_loop:
          on quit call command_seq_terminator;
          on seg_fault_error call universe_destroyed;
          do while ("1"b);
               call update_condition;
               input = "";
               call ioa_$nnl ("^/COMMAND :> ");
               call timed_input (input);
               call security_check;
               if input = "status" | input = "st" then call ship_status;
               else if input = "lscan" | input = "ls" then call long_scan;
               else if input = "sscan" | input = "ss" then call short_scan;
               else if input = "thrust" | input = "th" then call move_ship;
               else if input = "warpout" | input = "wp" then call warpout;
               else if input = "missile" | input = "ms" then call launch_missile;
               else if input = "lasers" | input = "lr" then call fire_lasers;
               else if input = "contact" | input = "ct" then call contact_ship;
               else if input = "dock" | input = "dk" then call dock;
               else if input = "sdestruct" | input = "sd" then call self_destruct;
               else if input = "deathray" | input = "dr" then call death_ray;
               else if input = "*" then call game_over;
               
               else if input = "." then call ioa_ ("^/^a ^a", MAIN, version);
               else if my -> ship.type = "Star Commander" then do;
                         if input = "cloaking-device" | input = "cd" then call cloaking_device;
                         else if input = "nova-blast" | input = "nb" then call nova_blast;
                         else if input = "star-gate" | input = "sg" then call create_stargate;
                         else if input = "tractor-beam" | input = "tb" then call tractor_beam;
                         else if input = "tractor-pull" | input = "tp" then call tractor_pull;
                         else if input = "trojan-horse" | input = "tj" then call trojan_horse;
                         else if input = "computer" | input = "cm" then call computer;
                         else if input = "monitor" | input = "mn" then call monitor_ship;
                         else if substr (input, 1, 1) = ":" then call escape_to_multics;
                         else if input = "?" then do;
                                   call command_list;
                                   call classified_com_list;
                              end;
                         else if input ^= "" then do;
                                   call ioa_ ("^/*** COMPUTER:");
                                   call ioa_ ("   That is not a standard ship command:");
                                   call ioa_ ("   Type a ""?"" for a list of proper commands");
                              end;
                    end;
               else if input = "?" then call command_list;
               else if input ^= "" then do;
                         call ioa_ ("^/*** COMPUTER:");
                         call ioa_ ("   That is not a standard ship command:");
                         call ioa_ ("   Type a ""?"" for a list of proper commands");
                         input = "";
                    end;
               
/* ENVIRONMENT CHECKING ROUTINES -- DAMAGE, MESSAGES, DEATHS, BLACK_HOLES, MONITOR, PSIONICS */
               call damage_check;
               call message_check;
               call death_check;
               call black_hole_check;
               call check_monitor;
               call psionics_check;
               call robot_functions;
               
          end;

/***** COMMAND ROUTINES *****/

ship_status: procedure;

          call ioa_ ("^/Ship name: ^a", my -> ship.name);
          call ioa_ ("Ship type: ^a", my -> ship.type);
          call ioa_ ("---------------------");
          call ioa_ ("Shield strength: ^d%", my -> ship.shields_cur);
          call ioa_ ("Missiles left: ^d", my -> ship.torps_cur);
          call ioa_ ("Energy left: ^du", my -> ship.energy_cur);
          call ioa_ ("Life support level: ^d", my -> ship.life_cur);
          call ioa_ ("---------------------");
          call ioa_ ("Condition: ^a", my -> ship.condition);
          call ioa_ ("Current location: ^a", my -> ship.location);
          
     end ship_status;
     
long_scan: procedure;

          dcl     x                      fixed bin init (0);
          dcl     stars                  (5) char (10) varying;
          
          stars = "";
          if my -> ship.location = "Romula" then stars (1) = "o";
          else if my -> ship.location = "Vindicar" then stars (2) = "o";
          else if my -> ship.location = "Telgar" then stars (3) = "o";
          else if my -> ship.location = "Shadow" then stars (4) = "o";
          else stars (5) = "o";
          do x = 1 to universe.number;
               edir = universe.pdir (x);
               call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
               if enemy ^= null () & edir ^= pdir then do;
                         if enemy -> ship.cloak_on = "0"b then do;
                                   if enemy -> ship.type = "Star Commander" then do;
                                             if enemy -> ship.location = "Romula" then stars (1) = stars (1) || "@";
                                             else if enemy -> ship.location = "Vindicar" then stars (2) = stars (2) || "@";
                                             else if enemy -> ship.location = "Telgar" then stars (3) = stars (3) || "@";
                                             else if enemy -> ship.location = "Shadow" then stars (4) = stars (4) || "@";
                                             else stars (5) = stars (5) || "@";
                                        end;
                                   else do;
                                             if enemy -> ship.location = "Romula" then stars (1) = stars (1) || "*";
                                             else if enemy -> ship.location = "Vindicar" then stars (2) = stars (2) || "*";
                                             else if enemy -> ship.location = "Telgar" then stars (3) = stars (3) || "*";
                                             else if enemy -> ship.location = "Shadow" then stars (4) = stars (4) || "*";
                                             else stars (5) = stars (5) || "*";
                                        end;
                              end;
                    end;
          end;
          call ioa_ ("\n   ROMULA    VINDICAR     TELGAR    SHADOW      ZORK");
          call ioa_ ("--------------------------------------------------------");
          call ioa_ ("|          |          |          |          |          |");
          call ioa_ ("|^a^12t|^a^23t|^a^34t|^a^45t|^a^56t|", stars (1), stars (2), stars (3), stars (4), stars (5));
          call ioa_ ("|          |          |          |          |          |");
          call ioa_ ("--------------------------------------------------------");
          
     end long_scan;

short_scan: procedure;

          dcl     x                      fixed bin init (0);
          dcl     shipname               (30) char (10);
          dcl     shiptype               (30) char (14);
          dcl     docked                 (30) char (15);
          dcl     present                fixed bin init (0);
          dcl     black_hole             bit (1) init ("0"b);
          
          shipname, shiptype, docked = "";
          call ioa_ ("^/SECTOR: ^a", my -> ship.location);
          do x = 1 to 5;
               if universe.black_hole (x) = my -> ship.location then black_hole = "1"b;
          end;
          do x = 1 to universe.number;
               edir = universe.pdir (x);
               call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
               if enemy ^= null () & edir ^= pdir then do;
                         if enemy -> ship.cloak_on = "0"b & enemy -> ship.location = my -> ship.location then do;
                                   present = present + 1;
                                   shipname (present) = enemy -> ship.name;
                                   shiptype (present) = enemy -> ship.type;
                                   if enemy -> ship.condition = "DOCKING" then docked (present) = "(Docking)";
                                   else if enemy -> ship.condition = "SHIELDS DOWN" then docked (present) = "(Shields Down)";
                              end;
                    end;
          end;
          call robot_sscan (present, shipname, shiptype, docked);
          if present = 0 & black_hole = "0"b then do;
                    call ioa_ ("*** SENSOR SCAN: Sector Void");
                    return;
               end;
          call ioa_ ("*** SENSOR SCAN:");
          if black_hole = "1"b then call ioa_ ("(((BLACK HOLE)))");
          do x = 1 to present;
               call ioa_ ("   ^a ^a ^a", shiptype (x), shipname (x), docked (x));
          end;
          
     end short_scan;
     
move_ship: procedure;

          dcl     open_sectors           (2) char (8);
          dcl     how_many               fixed bin init (1);
          dcl     old_loc                char (8) init ("");
          
          open_sectors, input = "";
          old_loc = my -> ship.location;
          if my -> ship.energy_cur < 10 then do;
                    call ioa_ ("^/WE haven't got the energy to move, sir");
                    return;
               end;
          else if my -> ship.tractor_on = "1"b then do;
                    call ioa_ ("^/TRACTOR BEAM holding our ship, sir");
                    return;
               end;
          if my -> ship.location = "Romula" then open_sectors (1) = "Vindicar";
          else if my -> ship.location = "Vindicar" then do;
                    how_many = 2;
                    open_sectors (1) = "Romula";
                    open_sectors (2) = "Telgar";
               end;
          else if my -> ship.location = "Telgar" then do;
                    how_many = 2;
                    open_sectors (1) = "Vindicar";
                    open_sectors (2) = "Shadow";
               end;
          else if my -> ship.location = "Shadow" then do;
                    how_many = 2;
                    open_sectors (1) = "Telgar";
                    open_sectors (2) = "Zork";
               end;
          else open_sectors (1) = "Shadow";
          do while (input = "");
               if how_many = 1 then call ioa_ ("^/OPEN SECTOR is ^a, sir", open_sectors (1));
               else call ioa_ ("^/OPEN SECTORS are ^a and ^a, sir", open_sectors (1), open_sectors (2));
               call ioa_$nnl ("NAVIGATION :> ");
               call timed_input (input);
               if input = "" then return;
               else if input = open_sectors (1) | input = open_sectors (2) then do;
                         if input ^= "" then do;
                                   call lock (my -> ship.lock);
                                   my -> ship.location = input;
                                   my -> ship.energy_cur = my -> ship.energy_cur - 10;
                                   my -> ship.energy_old = my -> ship.energy_old - 10;
                                   call unlock (my -> ship.lock);
                                   call ioa_ ("COURSE set for ^a, sir", input);
                                   call hazard_check;
                                   call inform_monitor (my -> ship.location);
                                   call inform_psionics (old_loc, my -> ship.location);
                              end;
                    end;
               else input = "";
          end;
          
hazard_check: procedure;

          dcl     x                      fixed bin init (0);
          dcl     course                 pic "999999";
          
          x = mod (clock (), 200) + 1
          course = mod (clock (), 99999) + 1;
          if x = 1 then call ioa_ ("^/ION STORM encountered on course ^a to ^a", course, input);
          else if x = 2 then call ioa_ ("^/ASTEROID BELT encountered on course ^a to ^a", course, input);
          if x < 3 then call hazard_damage;
          
hazard_damage: procedure;

          dcl     x                      fixed bin init (0);

          call lock (my -> ship.lock);
          x = mod (clock (), 10) + 1
          my -> ship.shields_cur = max (0, my -> ship.shields_cur - x);
          my -> ship.shields_old = max (0, my -> ship.shields_old - x);
          x = mod (clock (), 100) + 1
          my -> ship.energy_cur = max (0, my -> ship.energy_cur - x);
          my -> ship.energy_old = max (0, my -> ship.energy_old - x);
          call unlock (my -> ship.lock);
          
     end hazard_damage;
     
     end hazard_check;
     
     end move_ship;

warpout: procedure;

          dcl     x                      fixed bin init (0);
          dcl     old_loc                char (8) init ("");
          
          if my -> ship.energy_cur < 100 then do;
                    call ioa_ ("^/WE haven't got the energy to warpout, sir");
                    return;
               end;
          if my -> ship.tractor_on = "1"b then do;
                    call ioa_ ("^/TRACTOR BEAM holding our ship, sir");
                    return;
               end;
          old_loc = my -> ship.location;
          x = mod (clock (), 1000) + 1;
          if x > my -> ship.energy_cur then do;
                    call ioa_ ("^/<<< BOOOOOOOOOOM >>>");
                    call ioa_ ("You have warped into a star");
                    call game_over;
               end;
          call lock (my -> ship.lock);
          my -> ship.location = rand_location ();
          my -> ship.energy_cur = my -> ship.energy_cur - 100;
          my -> ship.energy_old = my -> ship.energy_old - 100;
          call unlock (my -> ship.lock);
          call ioa_ ("^/WARPOUT *****----------");
          call ioa_ ("New location: ^a", my -> ship.location);
          if old_loc ^= my -> ship.location then do;
                    call inform_monitor (my -> ship.location);
                    call inform_psionics (old_loc, my -> ship.location);
               end;
               
     end warpout;

launch_missile: procedure;

          dcl     is_he_there            bit (1) init ("0"b);
          dcl     hit                    bit (1) init ("0"b);
          
          if my -> ship.torps_cur = 0 then do;
                    call ioa_ ("^/WE are out of missiles, sir");
                    return;
               end;
          call ioa_ ("^/MISSILE ready to launch, sir");
          call ioa_$nnl ("Target name: ");
          call timed_input (input);
          if input = "" then return;
          target = input;
          call verify_target (target, is_he_there);
          if ^is_he_there then do;
                    call ioa_ ("*** SENSORS: Target ship ^a is not in this sector, sir", target);
                    return;
               end;
          input = "";
          do while (input = "");
               call ioa_$nnl ("MISSILE locked on target, sir: ");
               call timed_input (input);
               if input = "abort" | input = "ab" then do;
                         call ioa_ ("LAUNCH aborted, sir");
                         return;
                    end;
               else if input = "launch" | input = "l" then do;
                         call lock (my -> ship.lock);
                         my -> ship.torps_cur = my -> ship.torps_cur - 1;
                         my -> ship.torps_old = my -> ship.torps_old - 1;
                         call unlock (my -> ship.lock);
                         call ioa_ ("^/MISSILE launched, sir");
                         call hit_that_sucker (hit, "missile");
                         if target = "critical" then return;
                         if ^hit then do;
                                   call ioa_ ("MISSILE missed, sir");
                                   return;
                              end;
                         else call ioa_ ("<< BOOM >> MISSILE hit, sir");
                         call inflict_damage;
                         if target_is_a_robot (target) then return;
                         if enemy -> ship.psionics then do;
                                   call lock (enemy -> ship.lock);
                                   enemy -> ship.psi_mes (0) = "hit";
                                   enemy -> ship.psi_name (0) = my -> ship.name;
                                   enemy -> ship.psi_type (0) = my -> ship.type;
                                   call unlock (enemy -> ship.lock);
                              end;
                    end;
               else input = "";
          end;
     
     end launch_missile;

fire_lasers: procedure;

          dcl     is_he_there            bit (1) init ("0"b);
          dcl     hit                    bit (1) init ("0"b);
          
          if my -> ship.energy_cur < 10 then do;
                    call ioa_ ("^/WE haven't got the energy to fire lasers, sir");
                    return;
               end;
          call ioa_ ("^/LASER banks ready to fire, sir");
          call ioa_$nnl ("Target name: ");
          call timed_input (input);
          if input = "" then return;
          target = input;
          call verify_target (target, is_he_there);
          if ^is_he_there then do;
                    call ioa_ ("*** SENSORS: Target ship ^a is not in this sector, sir", target);
                    return;
               end;
          input = "";
          do while (input = "");
               call ioa_$nnl ("LASER banks locked on target, sir: ");
               call timed_input (input);
               if input = "deenergize" | input = "de" then do;
                         call ioa_ ("LASER banks deenergizing, sir");
                         return;
                    end;
               else if input = "fire" | input = "f" then do;
                         call lock (my -> ship.lock);
                         my -> ship.energy_cur = my -> ship.energy_cur - 10;
                         my -> ship.energy_old = my -> ship.energy_old - 10;
                         call unlock (my -> ship.lock);
                         call ioa_ ("^/LASERS fired, sir");
                         call hit_that_sucker (hit, "lasers");
                         if target = "critical" then return;
                         if ^hit then do;
                                   call ioa_ ("LASERS missed, sir");
                                   return;
                              end;
                         else call ioa_ ("<< ZAP >> LASERS hit, sir");
                         call inflict_damage;
                         if target_is_a_robot (target) then return;
                         if enemy -> ship.psionics then do;
                                   call lock (enemy -> ship.lock);
                                   enemy -> ship.psi_mes (0) = "hit";
                                   enemy -> ship.psi_name (0) = my -> ship.name;
                                   enemy -> ship.psi_type (0) = my -> ship.type;
                                   call unlock (enemy -> ship.lock);
                              end;
                    end;
               else input = "";
          end;
     
     end fire_lasers;

/* TARGETTING -- HIT DETERMINATION AND CRITICAL HITS */

verify_target: procedure (target, is_he_there);

          dcl     target                 char (10) parm;
          dcl     is_he_there            bit (1) parm;
          dcl     x                      fixed bin init (0);
          
          do x = 1 to universe.number;
               edir = universe.pdir (x);
               call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
               if enemy ^= null () & edir ^= pdir then do;
                         if enemy -> ship.location = my -> ship.location & enemy -> ship.name = target then do;
                                   is_he_there = "1"b;
                                   return;
                              end;
                    end;
          end;
          call robot_verify_target (target, is_he_there);
          
     end verify_target;
     
hit_that_sucker: procedure (hit, weapon);

          dcl     hit                    bit (1) parm;
          dcl     weapon                 char (*) parm;
          dcl     robot_was_the_target   bit (1) init ("0"b);
          dcl     x                      fixed bin init (0);
          
          call robot_hit_him (target, robot_was_the_target, weapon, hit);
          if robot_was_the_target then return;
          if enemy -> ship.type = "Star Commander" then do;
                    hit = "0"b;
                    return;
               end;
          if weapon = "missile" then do;
                    x = mod (clock (), 101) + 30;
                    if x > 125 then call critical_hit;
               end;
          else do;
                    x = mod (clock (), 100) + 1;
                    if x = 100 then call critical_hit;
               end;
          if x > enemy -> ship.shields_cur then hit = "1"b;
          else hit = "0"b;
          
critical_hit: procedure;

          if weapon ^= "plasma" then do;
                    call ioa_ ("^/<<< BOOOOOOOOOOM >>>");
                    call ioa_ ("<<< BOOOOOOOOOOM >>>");
                    call ioa_ ("^/CRITICAL centers have been hit on the ^a ^a!", enemy -> ship.type, enemy -> ship.name);
               end;
          call lock (enemy -> ship.lock);
          enemy -> ship.deathmes = "bang";
          call unlock (enemy -> ship.lock);
          
/* SET THE TARGET TO "CRITICAL" SO THAT UPON RETURNING, CONTROL GOES CENTRAL */
          target = "critical";
          
     end critical_hit;
     
     end hit_that_sucker;
     
inflict_damage: procedure;

          dcl     x                      fixed bin init (0);
          
          call robot_damage (target, x);
          if x = 666 then return;
          call lock (enemy -> ship.lock);
          if enemy -> ship.condition = "DOCKING" | enemy -> ship.condition = "D-RAY" | enemy -> ship.condition = "SHIELDS DOWN" | enemy -> ship.condition = "DROBOT" then do;
                    enemy -> ship.deathmes = "down";
                    call unlock (enemy -> ship.lock);
                    if index (my -> ship.condition, "ROBOT") = 0 then call ioa_ ("^/DEFLECTOR shields were down on the ^a ^a, sir", enemy -> ship.type, enemy -> ship.name);
                    return;
               end;
          do while (x = 0);
               x = mod (clock (), 4) + 1;
               if x = 1 then do;
                         if enemy -> ship.shields_cur = 0 then x = 0;
                         else do;
                                   x = mod (clock (), 10) + 1;
                                   enemy -> ship.shields_cur = max (0, enemy -> ship.shields_cur - x);
                                   if index (my -> ship.condition, "ROBOT") = 0 then call ioa_ ("^/SHIELDS damaged on the ^a ^a, sir", enemy -> ship.type, enemy -> ship.name);
                              end;
                    end;
               else if x = 2 then do;
                         if enemy -> ship.energy_cur = 0 then x = 0;
                         else do;
                                   x = mod (clock (), 100) + 1;
                                   enemy -> ship.energy_cur = max (0, enemy -> ship.energy_cur - x);
                                   if index (my -> ship.condition, "ROBOT") = 0 then call ioa_ ("^/ENGINES damaged on the ^a ^a, sir", enemy -> ship.type, enemy -> ship.name);
                              end;
                    end;
               else if x = 3 then do;
                         if enemy -> ship.torps_cur = 0 then x = 0;
                         else do;
                                   x = mod (clock (), 3) + 1;
                                   enemy -> ship.torps_cur = max (0, enemy -> ship.torps_cur - x);
                                   if index (my -> ship.condition, "ROBOT") = 0 then call ioa_ ("^/MISSILES damaged on the ^a ^a, sir", enemy -> ship.type, enemy -> ship.name);
                              end;
                    end;
               else if x = 4 then do;
                         if enemy -> ship.life_cur = 0 then x = 0;
                         else do;
                                   enemy -> ship.life_cur = enemy -> ship.life_cur - 1;
                                   if index (my -> ship.condition, "ROBOT") = 0 then call ioa_ ("^/LIFE SUPPORT systems damaged on the ^a ^a, sir", enemy -> ship.type, enemy -> ship.name);
                              end;
                    end;
          end;
          call unlock (enemy -> ship.lock);
          
     end inflict_damage;

contact_ship: procedure;

          dcl     x                      fixed bin init (0);
          dcl     sendto                 char (10) init ("");
          
          call ioa_$nnl ("^/WHO do you wish to contact, sir? ");
          call timed_input (input);
          if input = "" then return;
          sendto = input;
          if target_is_a_robot (sendto) then do;
                    call ioa_ ("^/TRANSMISSIONS can not be sent to a RobotShip, sir");
                    return;
               end;
          call ioa_ ("WHAT is the message, sir?");
          call ioa_$nnl ("---: ");
          call getline (input);
          if input = "" then do;
                    call ioa_ ("MESSAGE not sent, sir");
                    return;
               end;
          do x = 1 to universe.number;
               edir = universe.pdir (x);
               call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
               if enemy ^= null () & edir ^= pdir then do;
                         if enemy -> ship.name = sendto then do;
                                   call lock (enemy -> ship.lock);
                                   enemy -> ship.fromname = my -> ship.name;
                                   enemy -> ship.fromtype = my -> ship.type;
                                   enemy -> ship.message = input;
                                   call ioa_ ("MESSAGE sent, sir");
                                   return;
                              end;
                    end;
          end;
          call ioa_ ("TRANSMISSIONS are not being accepted by a ship named ^a, sir", sendto);
          
     end contact_ship;
     
dock: procedure;

          dcl     x                      fixed bin init (0);
          
          if my -> ship.tracname ^= "" then call ioa_ ("^/** STARBASE ^a: Please deactivate your Tractor Beam", my -> ship.location);
          if my -> ship.cloak_on = "1"b then call ioa_ ("^/** STARBASE ^a: Please deactivate your Cloaking Device", my -> ship.location);
          if my -> ship.tracname ^= "" | my -> ship.cloak_on = "1"b then return;
          call ioa_ ("^/** Welcome to STARBASE ^a **", my -> ship.location);
          if my -> ship.shields_cur > 0 then call ioa_ ("SHIELDS will be lowered for docking");
          on quit call ignore_signal;
          call inform_monitor ("docking");
          call inform_psionics ("docking", my -> ship.location);
          call lock (my -> ship.lock);
          my -> ship.condition = "DOCKING";
          my -> ship.shields_cur, my -> ship.shields_old = min (my -> ship.shields_max, my -> ship.shields_cur + 10);
          x = mod (clock (), 3) + 1;
          my -> ship.torps_cur, my -> ship.torps_old = min (my -> ship.torps_max, my -> ship.torps_cur + x);
          x = mod (clock (), 41) + 10;
          my -> ship.energy_cur, my -> ship.energy_old = min (my -> ship.energy_max, my -> ship.energy_cur + x);
          my -> ship.life_cur, my -> ship.life_old = min (10, my -> ship.life_cur + 1);
          call unlock (my -> ship.lock);
          do x = 1 to 200000;
               call robot_functions;
               if my -> ship.deathmes = "down" then call game_over;
               else if my -> ship.deathmes = "bang" then call damage_check;
          end;
          call update_condition;
          call ioa_ ("** DOCKING procedure completed.  Shields UP **");
          
ignore_signal: procedure;

/* PROCEDURE FOR NEUTRALIZING THE BREAK KEY UNTIL DOCKING IS FINISHED */

     end ignore_signal;
     
     end dock;

self_destruct: procedure;

          call ioa_$nnl ("^/INITIATE self destruct sequence: ");
          call timed_input (input);
          if input ^= "1a" then do;
                    call ioa_ ("INCORRECT sequence password given :: sequence terminated");
                    return;
               end;
          call ioa_ ("SELF destruct sequence initiated ***");
          call ioa_$nnl ("^/INITIATE sequence 2: ");
          call timed_input (input);
          if input ^= "2b" then do;
                    call ioa_ ("INCORRECT sequence password given :: sequence terminated");
                    return;
               end;
          call ioa_ ("SEQUENCE 2 initiated ***");
          call ioa_$nnl ("^/SELF destruct command: ");
          call timed_input (input);
          if input = "self-destruct" | input = "sd" then call share_the_misery;
          else if input = "abort" | input = "ab" then do;
                    call ioa_ ("SELF destruct abort override command given :: sequence terminated");
                    return;
               end;
          else do;
                    call ioa_ ("INCORRECT sequence password given :: sequence terminated");
                    return;
               end;
               
share_the_misery: procedure;

          dcl     x                      fixed bin init (0);
          dcl     damage                 fixed bin init (0);
          
          do x = 1 to universe.number;
               edir = universe.pdir (x);
               call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
               if enemy ^= null () & edir ^= pdir then do;
                         if enemy -> ship.location = my -> ship.location then do;
                                   damage = mod (clock (), 10) + 1;
                                   call lock (enemy -> ship.lock);
                                   enemy -> ship.shields_cur = max (0, enemy -> ship.shields_cur - damage);
                                   call unlock (enemy -> ship.lock);
                              end;
                    end;
          end;
          call game_over;
          
     end share_the_misery;
     
     end self_destruct;
     
/***** STAR COMMANDER COMMAND ROUTINES *****/

cloaking_device: procedure;

          if my -> ship.energy_cur < 500 then do;
                    call ioa_ ("^/WE haven't got the energy to activate the Cloaking Device, sir");
                    return;
               end;
          if my -> ship.cloak_on = "0"b then do;
                    call ioa_ ("^/CLOAKING DEVICE activated, sir");
                    call lock (my -> ship.lock);
                    my -> ship.cloak_on = "1"b;
                    my -> ship.energy_cur = my -> ship.energy_cur - 500;
                    my -> ship.energy_old = my -> ship.energy_old - 500;
                    call unlock (my -> ship.lock);
                    call inform_monitor ("vanished");
               end;
          else do;
                    input = "";
                    call ioa_ ("^/CLOAKING DEVICE is already activated, sir");
                    do while (input = "");
                         call ioa_$nnl ("Deactivate? ");
                         call timed_input (input);
                         if input = "yes" | input = "y" then do;
                                   call ioa_ ("CLOAKING DEVICE deactivated, sir");
                                   call lock (my -> ship.lock);
                                   my -> ship.cloak_on = "0"b;
                                   call unlock (my -> ship.lock);
                                   return;
                              end;
                         if input ^= "no" & input ^= "n" then do;
                                   call ioa_ ("^/Please type ""yes"" or ""no"".");
                                   input = "";
                              end;
                    end;
               end;
               
     end cloaking_device;
     
nova_blast: procedure;

          dcl     is_he_there            bit (1) init ("0"b);
          dcl     x                      fixed bin init (0);
          
          if my -> ship.energy_cur < 100 then do;
                    call ioa_ ("^/WE haven't got the energy to launch a Nova Blast, sir");
                    return;
               end;
          call ioa_ ("^/NOVA BLAST ready, sir");
          call ioa_$nnl ("Target name: ");
          call timed_input (input);
          if input = "" then return;
          target = input;
          call verify_target (target, is_he_there);
          if ^is_he_there then do;
                    call ioa_ ("*** SENSORS: Target ship ^a is not in this sector, sir", target);
                    return;
               end;
          call ioa_ ("NOVA BLAST launched, sir");
          if target_is_a_robot (target) then call robot_death (target);
          else do;
                    call lock (enemy -> ship.lock);
                    enemy -> ship.life_cur = 0;
                    if enemy -> ship.condition = "DOCKING" | enemy -> ship.condition = "D-RAY" then enemy -> ship.deathmes = "down";
                    call unlock (enemy -> ship.lock);
               end;
          call lock (my -> ship.lock);
          my -> ship.energy_cur = my -> ship.energy_cur - 100;
          my -> ship.energy_old = my -> ship.energy_old - 100;
          call unlock (my -> ship.lock);
          
     end nova_blast;
     
create_stargate: procedure;

          dcl     old_loc                char (8) init ("");
          
          if my -> ship.energy_cur < 1000 then do;
                    call ioa_ ("^/WE haven't got the energy to create a Star Gate, sir ");
                    return;
               end;
          old_loc = my -> ship.location;
          call ioa_ ("^/STAR GATE opened, sir");
          input = "";
          do while (input = "");
               call ioa_$nnl ("Target sector: ");
               call timed_input (input);
               if input = "" then return;
               else if input ^= "Romula" & input ^= "Vindicar" & input ^= "Telgar" & input ^= "Shadow" & input ^= "Zork" then input = "";
          end;
          call lock (my -> ship.lock);
          my -> ship.location = input;
          my -> ship.energy_cur = my -> ship.energy_cur - 1000;
          my -> ship.energy_old = my -> ship.energy_old - 1000;
          call unlock (my -> ship.lock);
          call ioa_ ("^/<< VOOM >>>>>>>>>>>>>>>>>>>>");
          call ioa_ ("New location: ^a", my -> ship.location);
          call ioa_ ("^/STAR GATE closed, sir");
          if old_loc ^= my -> ship.location then do;
                    call inform_monitor (my -> ship.location);
                    call inform_psionics (old_loc, my -> ship.location);
               end;
               
     end create_stargate;
     
tractor_beam: procedure;

          dcl     is_he_there            bit (1) init ("0"b);
          dcl     x                      fixed bin init (0);
          
          if my -> ship.energy_cur < 50 then do;
                    call ioa_ ("^/WE haven't go the energy to activate the Tractor Beam, sir");
                    return;
               end;
          if my -> ship.tracname = "" then do;
                    call ioa_ ("^/TRACTOR BEAM ready, sir");
                    call ioa_$nnl ("Target name: ");
                    call timed_input (input);
                    if input = "" then return;
                    target = input;
                    call verify_target (target, is_he_there);
                    if ^is_he_there then do;
                              call ioa_ ("*** SENSORS: Target ship ^a is not in this sector, sir", target);
                              return;
                         end;
                    call ioa_ ("TRACTOR BEAM activated, sir");
                    call lock (enemy -> ship.lock);
                    enemy -> ship.tractor_on = "1"b;
                    call unlock (enemy -> ship.lock);
                    call lock (my -> ship.lock);
                    my -> ship.tracname = enemy -> ship.name;
                    my -> ship.energy_cur = my -> ship.energy_cur - 50;
                    my -> ship.energy_old = my -> ship.energy_old - 50;
                    call unlock (my -> ship.lock);
               end;
          else do;
                    call ioa_ ("^/TRACTOR BEAM is already activated, sir");
                    input = "";
                    do while (input = "");
                         call ioa_$nnl ("Deactivate? ");
                         call timed_input (input);
                         if input = "yes" | input = "y" then do;
                                   do x = 1 to universe.number;
                                        edir = universe.pdir (x);
                                        call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
                                        if enemy ^= null () & edir ^= pdir & enemy -> ship.name = my -> ship.tracname then do;
                                                  call lock (enemy -> ship.lock);
                                                  enemy -> ship.tractor_on = "0"b;
                                                  call unlock (enemy -> ship.lock);
                                             end;
                                   end;
                                   call lock (my -> ship.lock);
                                   my -> ship.tracname = "";
                                   call unlock (my -> ship.lock);
                                   call ioa_ ("TRACTOR BEAM deactivated, sir");
                              end;
                         else if input ^= "no" & input ^= "n" then do;
                                   call ioa_ ("^/Please type ""yes"" or ""no"".");
                                   input = "";
                              end;
                    end;
               end;
               
     end tractor_beam;

monitor_ship: procedure;

          dcl     monitor_who            char (10) init ("");
          dcl     is_he_there            bit (1) init ("0"b);
          dcl     x                      fixed bin init (0);
          
          if my -> ship.monname = "#" then do;
                    call ioa_ ("^/MONITOR probe ready, sir");
                    call ioa_$nnl ("Target name: ");
                    call timed_input (input);
                    if input = "" then return;
                    monitor_who = input;
                    call verify_target (monitor_who, is_he_there);
                    if ^is_he_there then do;
                              call ioa_ ("*** SENSORS: Target ship ^a is not in this sector, sir", monitor_who);
                              return;
                         end;
                    call lock (enemy -> ship.lock);
                    enemy -> ship.monitored_by = my -> ship.name;
                    call unlock (enemy -> ship.lock);
                    call lock (my -> ship.lock);
                    my -> ship.monname = enemy -> ship.name;
                    my -> ship.montype = enemy -> ship.type;
                    call unlock (my -> ship.lock);
                    call ioa_ ("MONITOR probe activated, sir");
                    return;
               end;
          call ioa_ ("^/MONITOR probe is already activated, sir");
          input = "";
          do while (input = "");
               call ioa_$nnl ("Deactivate? ");
               call timed_input (input);
               if input = "yes" | input = "y" then do;
                         do x = 1 to universe.number;
                              edir = universe.pdir (x);
                              call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
                              if enemy ^= null () & edir ^= pdir then do;
                                        if enemy -> ship.name = my -> ship.monname then do;
                                                  call lock (enemy -> ship.lock);
                                                  enemy -> ship.monitored_by = "";
                                                  call unlock (enemy -> ship.lock);
                                                  call lock (my -> ship.lock);
                                                  my -> ship.monname = "#";
                                                  my -> ship.montype = "#";
                                                  my -> ship.monloc = "";
                                                  call unlock (my -> ship.lock);
                                                  call ioa_ ("MONITOR probe deactivated, sir");
                                             end;
                                   end;
                         end;
                    end;
               else if input ^= "no" & input ^= "n" then do;
                         call ioa_ ("^/Please type ""yes"" or ""no"".");
                         input = "";
                    end;
          end;
          
     end monitor_ship;
     
tractor_pull: procedure;

          dcl     x                      fixed bin init (0);
          
          if my -> ship.tracname = "" then do;
                    call ioa_ ("^/TRACTOR BEAM is not in operation, sir");
                    return;
               end;
          else if my -> ship.energy_cur < 100 then do;
                    call ioa_ ("^/WE haven't got the energy to pull the ship, sir");
                    return;
               end;
          do x = 1 to universe.number;
               edir = universe.pdir (x);
               call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
               if enemy ^= null () & edir ^= pdir then do;
                         if my -> ship.tracname = enemy -> ship.name then do;
                                   if my -> ship.location = enemy -> ship.location then do;
                                             call ioa_ ("^/The ""^a"" is already in ^a, sir", my -> ship.tracname, enemy -> ship.location);
                                             return;
                                        end;
                                   call lock (enemy -> ship.lock);
                                   enemy -> ship.location = my -> ship.location;
                                   if enemy -> ship.deathmes = "" then enemy -> ship.deathmes = "pull";
                                   call unlock (enemy -> ship.lock);
                                   call ioa_ ("^/TRACTOR BEAM pulling the ""^a"" into ^a, sir", my -> ship.tracname, enemy -> ship.location);
                                   call lock (my -> ship.lock);
                                   my -> ship.energy_cur = my -> ship.energy_cur - 10;
                                   my -> ship.energy_old = my -> ship.energy_old - 10;
                                   call unlock (my -> ship.lock);
                                   return;
                              end;
                    end;
          end;
          
     end tractor_pull;

trojan_horse: procedure;

          dcl     x                      fixed bin init (0);
          dcl     victim                 char (10) init ("");
          
          call ioa_$nnl ("^/WHO is to receive the Trojan Horse, sir? ");
          call timed_input (input);
          if input = "" then return;
          victim = input;
          call ioa_ ("WHAT is the command, sir?");
          call ioa_$nnl ("---: ");
          call timed_input (input);
          if input = "" then do;
                    call ioa_ ("TROJAN HORSE not sent, sir");
                    return;
               end;
          do x = 1 to universe.number;
               edir = universe.pdir (x);
               call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
               if enemy ^= null () & edir ^= pdir then do;
                         if enemy -> ship.name = victim then do;
                                   call lock (enemy -> ship.lock);
                                   enemy -> ship.fromname = my -> ship.name;
                                   enemy -> ship.fromtype = "Trojan Horse";
                                   enemy -> ship.message = "TH:" || input;
                                   call unlock (enemy -> ship.lock);
                                   call ioa_ ("TROJAN HORSE sent, sir");
                                   return;
                              end;
                    end;
          end;
          call ioa_ ("TRANSMISSIONS are not being accepted by a ship named ^a, sir", victim);
          
     end trojan_horse;
     
/* COMPUTER COMMAND ROUTINES */

computer: procedure;

          call ioa_$nnl ("^/*** COMPUTER ON ::: ");
          call timed_input (input);
          if input = "" then return;
          else if input = "srunners" | input = "srs" then call list_all_players;
          else if input = "estatus" | input = "est" then call enemy_status;
          else if input = "probe" | input = "prb" then call probe;
          else if input = "bhreport" | input = "bhr" then call black_hole_report;
          else if input = "rsreport" | input = "rsr" then call robotship_report;
          else if input = "?" then call computer_com_list;
          else do;
                    call ioa_ ("^/*** COMPUTER:");
                    call ioa_ ("   That is not a standard computer command:");
                    call ioa_ ("   Type ""?"" for a list of proper computer commands");
               end;

list_all_players: procedure;

          dcl     x                      fixed bin init (0);
          
          call ioa_ ("^/Starrunners: ^d^/", universe.number);
          do x = 1 to universe.number;
               edir = universe.pdir (x);
               call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
               if enemy ^= null () then do;
                         if enemy = my then call ioa_ (" * ^a: ^a ^a (^a)", my -> ship.user, my -> ship.type, my -> ship.name, my -> ship.location);
                         else if enemy -> ship.name = "" | enemy -> ship.type = "" then call ioa_ ("   ^a: CREATING SHIP", enemy -> ship.user);
                         else call ioa_ ("   ^a: ^a ^a (^a)", enemy -> ship.user, enemy -> ship.type, enemy -> ship.name, enemy -> ship.location);
                    end;
          end;
          
     end list_all_players;
     
enemy_status: procedure;

          dcl     shipfile               char (10) init ("");
          dcl     x                      fixed bin init (0);
          
          call ioa_$nnl ("^/STARFILE name: ");
          call timed_input (input);
          if input = "" then return;
          shipfile = input;
          do x = 1 to universe.number;
               edir = universe.pdir (x);
               call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
               if enemy ^= null () & edir ^= pdir then do;
                         if enemy -> ship.name = shipfile & enemy -> ship.location ^= "PHASING" then do;
                                   call ioa_ ("^/::: STARFILE ^d :::", x);
                                   call ioa_ ("^a ^a status:", enemy -> ship.type, enemy -> ship.name);
                                   call ioa_ ("^/Shield strength: ^d%^[   DOWN]", enemy -> ship.shields_cur, (enemy -> ship.shields.cur = 0));
                                   call ioa_ ("Missiles left: ^d", enemy -> ship.torps_cur);
                                   call ioa_ ("Energy left: ^du", enemy -> ship.energy_cur);
                                   call ioa_ ("Life support level: ^d", enemy -> ship.life_cur);
                                   call ioa_ ("Current location: ^a", enemy -> ship.location);
                                   return;
                              end;
                    end;
          end;
          call ioa_ ("^/*** COMPUTER:");
          call ioa_ ("   Unable to identify specified ship: ^a", shipfile);
          
     end enemy_status;

probe: procedure;

          dcl     probe_who              char (10) init ("");
          dcl     x                      fixed bin init (0);
          
          call ioa_$nnl ("^/*** PROBE ship: ");
          call timed_input (input);
          if input = "" then return;
          probe_who = input;
          do x = 1 to universe.number;
               edir = universe.pdir (x);
               call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
               if enemy ^= null () & edir ^= pdir then do;
                         if enemy -> ship.name = probe_who & enemy -> ship.location ^= "PHASING" then do;
                                   call ioa_ ("*** PROBE sector: ^a", enemy -> ship.location);
                                   if enemy -> ship.condition = "DOCKING" then call ioa_ ("^19tDOCKING");
                                   else if enemy -> ship.condition = "SHIELDS DOWN" then call ioa_ ("^19tSHIELDS DOWN");
                                   if enemy -> ship.tractor_on = "1"b then call ioa_ ("^19tTRACTOR BEAM HELD");
                                   if enemy -> ship.cloak_on = "1"b then call ioa_ ("^19tCLOAKING DEVICE ON");
                                   return;
                              end;
                    end;
          end;
          call ioa_ ("*** PROBE: Starfile on ^a could not be located", probe_who);
          
     end probe;
     
black_hole_report: procedure;

          dcl     chart_mark             (5) char (2);
          dcl     x                      fixed bin init (0);
          
          chart_mark = "";
          do x = 1 to universe.holes;
               if universe.black_hole (x) = "Romula" then chart_mark (1) = "()";
               else if universe.black_hole (x) = "Vindicar" then chart_mark (2) = "()";
               else if universe.black_hole (x) = "Telgar" then chart_mark (3) = "()";
               else if universe.black_hole (x) = "Shadow" then chart_mark (4) = "()";
               else if universe.black_hole (x) = "Zork" then chart_mark (5) = "()";
          end;
          call ioa_ ("^/ROMULA  VINDICAR  TELGAR  SHADOW  ZORK");
          call ioa_ ("------  --------  ------  ------  ----");
          call ioa_ ("  ^2a^7x^2a^7x^2a^6x^2a^5x^2a", chart_mark (1), chart_mark (2), chart_mark (3), chart_mark (4), chart_mark (5));
          
     end black_hole_report;

robotship_report: procedure;

          dcl     x                      fixed bin init (0);
          
          call ioa_ ("^/RobotShip Report:");
          do x = 1 to 20;
               if universe.robot (x).location ^= "" then call ioa_ ("^3xRobotShip ^a (^a) ^a", universe.robot (x).name, universe.robot (x).location, universe.robot (x).condition);
          end;
          
     end robotship_report;
     
     end computer;

escape_to_multics: procedure;

          dcl     command                char (256) init ("");
          
          command = after (input, ":");
          call do (command);
          
     end escape_to_multics;
     
/***** ARMEGEDDON ROUTINES -- TRASH HIS SHIP, GOODBYE CRUEL UNIVERSE *****/

game_over: procedure;

          dcl     (x, y)                 fixed bin init (0);
          
          call timer_manager_$reset_alarm_call (inform_routines);
          if input = "*" then goto update_universe;
          do x = 1 to universe.number;
               edir = universe.pdir (x);
               call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
               if enemy ^= null () & edir ^= pdir & enemy -> ship.name ^= "" & enemy -> ship.type ^= "" & (my -> ship.type = "Starship" | my -> ship.type = "Cruiser" | my -> ship.type = "Destroyer" | (my -> ship.type = "Star Commander" & my -> ship.life_cur = 0)) then do;
                         call lock (enemy -> ship.lock);
                         enemy -> ship.deathmes = "dead";
                         enemy -> ship.deadname = my -> ship.name;
                         enemy -> ship.deadtype = my -> ship.type;
                         if my -> ship.tracname = enemy -> ship.name then enemy -> ship.tractor_on = "0"b;
                         if enemy -> ship.tracname = my -> ship.name then enemy -> ship.tracname = "";
                         if my -> ship.monname = enemy -> ship.name then enemy -> ship.monitored_by = "";
                         call unlock (enemy -> ship.lock);
                    end;
          end;
          
update_universe:
          call robot_release ((my -> ship.user));
          call lock (universe.lock);
          do x = 1 to universe.number;
               if universe.pdir (x) = pdir then do;
                         do y = x to universe.number;
                              universe.pdir (y) = universe.pdir (y + 1);
                              universe.user (y) = universe.user (y + 1);
                              universe.unique_id (y) = universe.unique_id (y + 1);
                         end;
                         universe.pdir (universe.number) = "";
                         universe.user (universe.number) = "";
                         universe.unique_id (universe.number) = 0;
                         universe.number = universe.number - 1;
                    end;
          end;
          call unlock (universe.lock);
          call hcs_$delentry_seg (my, code);
          call ioa_ ("^/<<< YOU HAVE BEEN VAPORIZED >>>");
          call ioa_ ("^/Thank you for playing STARRUNNERS.");
          goto end_of_game;
          
     end game_over;
     
universe_destroyed: procedure;

          univptr = null ();
          call hcs_$initiate (dname, xname, "", 0, 0, univptr, code);
          if code ^= 0 & univptr = null () then do;
                    call ioa_ ("^/*** GALACTIC IMPLOSION IMMINENT ***^/Alas, the universe has been destroyed...");
                    goto end_of_game;
               end;
          call ioa_ ("^/*** SENSORS: Enemy ship is gone, sir");
          enemy = null ();
          goto command_loop;
          
     end universe_destroyed;

/***** INFORMING ROUTINES *****/

inform_monitor: procedure (info);

          dcl     info                   char (8) aligned parm;
          dcl     x                      fixed bin init (0);
          
          if my -> ship.monitored_by = "" then return;
          do x = 1 to universe.number;
               edir = universe.pdir (x);
               call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
               if enemy ^= null () & edir ^= pdir then do;
                         if enemy -> ship.name = my -> ship.monitored_by then do;
                                   call lock (enemy -> ship.lock);
                                   enemy -> ship.monloc = info;
                                   call unlock (enemy -> ship.lock);
                              end;
                    end;
          end;
          if info = "vanished" then do;
                    call lock (my -> ship.lock);
                    my -> ship.monitored_by = "";
                    call unlock (my -> ship.lock);
               end;
               
     end inform_monitor;
     
inform_psionics: procedure (old_loc, new_loc);

          dcl     old_loc                char (*) parm;
          dcl     new_loc                char (*) aligned parm;
          dcl     x                      fixed bin init (0);
          
          do x = 1 to universe.number;
               edir = universe.pdir (x);
               call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
               if enemy ^= null () & edir ^= pdir & enemy -> ship.psionics then do;
                         if old_loc = enemy -> ship.location | new_loc = enemy -> ship.location | old_loc = "docking" then do;
                                   call lock (enemy -> ship.lock);
                                   enemy -> ship.psi_num, y = enemy -> ship.psi_num + 1;
                                   enemy -> ship.psi_name (y) = my -> ship.name;
                                   enemy -> ship.psi_type (y) = my -> ship.type;
                                   if old_loc = enemy -> ship.location then enemy -> ship.psi_mes (y) = "left";
                                   else if old_loc = "docking" then enemy -> ship.psi_mes (y) = new_loc;
                                   else if new_loc = enemy -> ship.location then enemy -> ship.psi_mes (y) = "entered";
                                   call unlock (enemy -> ship.lock);
                              end;
                    end;
          end;
          
     end inform_psionics;

command_list: procedure;

          call ioa_ ("^/Commands:");
          call ioa_ ("   (ss) sscan ------------ Short range scan");
          call ioa_ ("   (ls) lscan ------------ Long range scan");
          call ioa_ ("   (st) status ----------- Ship status");
          call ioa_ ("   (th) thrust ----------- Move ship to an adjacent sector");
          call ioa_ ("   (wp) warpout ---------- Hyperspace jump to a random sector");
          call ioa_ ("   (ms) missile ---------- Missile attck");
          call ioa_ ("   (lr) lasers ----------- Laser attack");
          call ioa_ ("   (ct) contact ---------- Communication with another ship");
          call ioa_ ("   (sd) sdestruct -------- Self destruct");
          call ioa_ ("   (dr) deathray --------- Fire Death Ray");
          call ioa_ ("   (dk) dock ------------- Dock at sector-starbase");
          call ioa_ ("        * ---------------- Quit from game (Ship explodes)");
          
     end command_list;
     
classified_com_list: procedure;

          call ioa_ ("^/Classified commands:");
          call ioa_ ("   (nb) nova-blast ------- Instantly destroys any ship");
          call ioa_ ("   (cm) computer --------- Accesses classified computer files");
          call ioa_ ("   (tb) tractor-beam ----- Tractor beam");
          call ioa_ ("   (tp) tractor-pull ----- Pull ship into sector");
          call ioa_ ("   (sg) star-gate -------- Star gate creation");
          call ioa_ ("   (cd) cloaking-device -- Cloaking device");
          call ioa_ ("   (mn) monitor ---------- Monitor ship");
          call ioa_ ("   (tj) trojan-horse ----- Send trojan horse command");
          
     end classified_com_list;
     
computer_com_list: procedure;

          call ioa_ ("^/Computer commands:");
          call ioa_ ("   (srs) srunners -------- Player listing");
          call ioa_ ("   (est) estatus --------- Enemy ship status");
          call ioa_ ("   (prb) probe ----------- Probe for ship");
          call ioa_ ("   (bhr) bhreport -------- Black hole report");
          call ioa_ ("   (rsr) rsreport -------- RobotShip report");
          
     end computer_com_list;

/***** ENVIRONMENT CHECKING ROUTINES *****/

damage_check: procedure;

          if my -> ship.deathmes = "bang" then do;
                    call ioa_ ("^/*** RED ALERT ***");
                    call ioa_ ("*** RED ALERT ***");
                    call ioa_ ("^/CRITICAL centers have been hit, sir!!!");
                    call game_over;
               end;
          else if my -> ship.deathmes = "pull" then do;
                    call ioa_ ("^/TRACTOR BEAM has pulled our ship into ^a, sir", my -> ship.location);
                    my -> ship.deathmes = "";
               end;
          if my -> ship.life_cur = 0 then call game_over;
          else if my -> ship.deathmes = "down" then call game_over;
          if my -> ship.shields_cur ^= my -> ship.shields_old then do;
                    call ioa_ ("^/<<< FOOOOOOOOOOM >>> SHIELDS have been hit, sir");
                    call ioa_ ("Shield strength has been reduced to ^d%", my -> ship.shields_cur);
                    call lock (my -> ship.lock);
                    my -> ship.shields_old = my -> ship.shields_cur;
                    call unlock (my -> ship.lock);
               end;
          if my -> ship.energy_cur ^= my -> ship.energy_old then do;
                    call ioa_ ("^/<<< FOOOOOOOOOOM >>> ENGINES have been hit, sir");
                    call ioa_ ("Energy remaining: ^du", my -> ship.energy_cur);
                    call lock (my -> ship.lock);
                    my -> ship.energy_old = my -> ship.energy_cur;
                    call unlock (my -> ship.lock);
               end;
          if my -> ship.torps_cur ^= my -> ship.torps_old then do;
                    call ioa_ ("^/<<< FOOOOOOOOOOM >>> MISSILES have been hit, sir");
                    call ioa_ ("Missiles remaining: ^d", my -> ship.torps_cur);
                    call lock (my -> ship.lock);
                    my -> ship.torps_old = my -> ship.torps_cur;
                    call unlock (my -> ship.lock);
               end;
          if my -> ship.life_cur ^= my -> ship.life_old then do;
                    call ioa_ ("^/<<< FOOOOOOOOOOM >>> LIFE SUPPORT systems have been hit, sir");
                    call ioa_ ("Life support level: ^d", my -> ship.life_cur);
                    call lock (my -> ship.lock);
                    my -> ship.life_old = my -> ship.life_cur;
                    call unlock (my -> ship.lock);
               end;
          if my -> ship.psi_mes (0) = "hit" then do;
                    call ioa_ ("^/PSIONICS: We have just been attacked by the ^a ^a, sir", my -> ship.psi_type (0), my -> ship.psi_name (0));
                    call lock (my -> ship.lock);
                    my -> ship.psi_mes (0), my -> ship.psi_name (0), my -> ship.psi_type (0) = "";
                    call unlock (my -> ship.lock);
               end;
               
     end damage_check;
     
message_check: procedure;

          if my -> ship.message = "" then return;
          if substr (my -> ship.message, 1, 3) = "TH:" & my -> ship.fromtype = "Trojan Horse" then do;
                    if my -> ship.type = "Star Commander" then call ioa_ ("^/COMMUNICATIONS: We've trapped a Trojan Horse from the Star Commander ^a^/^16x(^a)", my -> ship.fromname, substr (my -> ship.message, 4));
                    else call do (substr (my -> ship.message, 4));
                    call lock (my -> ship.lock);
                    my -> ship.fromname, my -> ship.fromtype, my -> ship.messge = "";
                    call unlock (my -> ship.lock);
                    return;
               end;
          call ioa_ ("^/COMMUNICATIONS: New transmission from the ^a ^a, sir", my -> ship.fromtype, my -> ship.fromname);
          call ioa_ ("It says: ^a", my -> ship.message);
          call lock (my -> ship.lock);
          my -> ship.message, my -> ship.fromname, my -> ship.fromtype = "";
          call unlock (my -> ship.lock);
          
     end message_check;
     
death_check: procedure;

          if my -> ship.deathmes ^= "dead" then return;
          call ioa_ ("^/  <<< BOOOOOM >>>");
          call ioa_ ("<<<<< BOOOOOM >>>>>");
          call ioa_ ("  <<< BOOOOOM >>>");
          call ioa_ ("^/SENSORS are picking up metallic debris from the ^a ^a, sir", my -> ship.deadtype, my -> ship.deadname);
          if my -> ship.deadname = my -> ship.monname then do;
                    call lock (my -> ship.lock);
                    my -> ship.monloc = "";
                    my -> ship.monname, my -> ship.montype = "#";
                    call unlock (my -> ship.lock);
                    call ioa_ ("^/MONITOR probe lost, sir");
               end;
          call lock (my -> ship.lock);
          my -> ship.deathmes, my -> ship.deadname, my -> ship.deadtype = "";
          call unlock (my -> ship.lock);
          
     end death_check;
     
check_monitor: procedure;

          if my -> ship.monloc = "" then return;
          if my -> ship.monloc = "docking" then call ioa_ ("^/*** MONITOR: ^a ^a has just docked", my -> ship.montype, my -> ship.monname);
          else if my -> ship.monloc = "vanished" then do;
                    call ioa_ ("^/*** MONITOR: Probe lost on ^a ^a", my -> ship.montype, my -> ship.monname);
                    call lock (my -> ship.lock);
                    my -> ship.monname, my -> ship.montype, my -> ship.monloc = "";
                    call unlock (my -> ship.lock);
               end;
          else call ioa_ ("^/*** MONITOR: ^a ^a is now in ^a", my -> ship.montype, my -> ship.monname, my -> ship.monloc);
          call lock (my -> ship.lock);
          my -> ship.monloc = "";
          call unlock (my -> ship.lock);
          
     end check_monitor;
     
psionics_check: procedure;

          dcl     x                      fixed bin init (0);
          
          if my -> ship.psi_num > 0 then do;
                    if my -> ship.psi_mes (1) ^= "left" & my -> ship.psi_mes (1) ^= "entered" then call ioa_ ("^/PSIONICS: The ^a ^a has just docked at ^a, sir", my -> ship.psi_type (1), my -> ship.psi_name (1), my -> ship.psi_mes (1));
                    else call ioa_ ("^/PSIONICS: The ^a ^a has just ^a our sector, sir", my -> ship.psi_type (1), my -> ship.psi_name (1), my -> ship.psi_mes (1));
                    do x = 2 to my -> ship.psi_num;
                         if my -> ship.psi_mes (x) ^= "left" & my -> ship.psi_mes (x) ^= "entered" then call ioa_ ("^10xThe ^a ^a has just docked at ^a, sir", my -> ship.psi_type (x), my -> ship.psi_name (x), my -> ship.psi_mes (x));
                         else call ioa_ ("^10xThe ^a ^a has just ^a our sector, sir", my -> ship.psi_type (x), my -> ship.psi_name (x), my -> ship.psi_mes (x));
                    end;
                    call lock (my -> ship.lock);
                    my -> ship.psi_name, my -> ship.psi_type, my -> ship.psi_mes = "";
                    my -> ship.psi_num = 0;
                    call unlock (my -> ship.lock);
               end;
               
          if my -> ship.psionics then return;
          
          x = mod (clock (), 2000) + 1;
          if x > 1 then return;
          call ioa_ ("^/=== STAR FLEET COMMAND ===");
          call ioa_ ("^/=== Transmission to: ^a ^a", my -> ship.type, my -> ship.name);
          call ioa_ ("=== You have been entrusted with our newest secret weapon: Psionics! ===");
          call ioa_ ("=== Prepare to matter-transmit him aboard your ship. Congratulations ===");
          call ioa_ ("^/MATTER-TRANSMITTER ready for boarding, sir");
          call ioa_ (">>>Energizeeeeeeeeeeeeeeeeeeeeeeeeeeeee...");
          call ioa_ ("PSIONIC board ship, sir");
          call lock (my -> ship.lock);
          my -> ship.psionics = "1"b;
          call unlock (my -> ship.lock);
          
     end psionics_check;

/***** BLACK HOLE ROUTINES *****/

black_hole_check: procedure;

          call black_hole_init;
          call new_black_hole;
          call rand_new_hole;
          call suck_him_in;
          
black_hole_init: procedure;

          dcl     hole_here              bit (1) init ("0"b);
          dcl     x                      fixed bin init (0);
          
          if my -> ship.black_hole ^= "start" then return;
          call lock (my -> ship.lock);
          my -> ship.black_hole = "";
          call unlock (my -> ship.lock);
          do x = 1 to universe.holes;
               if universe.black_hole (x) = my -> ship.location then hole_here = "1"b;
          end;
          if hole_here = "1"b then do;
                    call ioa_ ("^/*** RED ALERT ***");
                    call ioa_ ("^/SENSORS indicate that we have just phased into a black hole sector, sir!");
                    if my -> ship.type ^= "Star Commander" then call pulling_damage;
               end;
          if universe.holes = 1 & hole_here = "1"b then return;
          else if universe.holes > 0 then do;
                    call ioa_ ("^/*** YELLOW ALERT ***");
                    call ioa_ ("^/SENSORS indicate black holes are present in the following sectors:");
               end;
          do x = 1 to universe.holes;
               call ioa_ ("   ^a", universe.black_hole (x));
          end;
          
     end black_hole_init;
     
new_black_hole: procedure;

          if my -> ship.black_hole = "" then return;
          if my -> ship.black_hole = my -> ship.location then do;
                    call ioa_ ("^/*** RED ALERT ***");
                    call ioa_ ("^/SENSORS indicate that a black hole has just developed in our sector, sir!");
                    if my -> ship.type ^= "Star Commander" then call pulling_damage;
                    call lock (my -> ship.lock);
                    my -> ship.black_hole = "";
                    call unlock (my -> ship.lock);
               end;
               
     end new_black_hole;
     
rand_new_hole: procedure;

          dcl     new_hole               char (8) init ("");
          dcl     x                      fixed bin init (0);
          
          x = mod (clock (), 1000) + 1
          if x > 1 then return;
          new_hole = rand_location ();
          do x = 1 to universe.holes;
               if universe.black_hole (x) = new_hole then return;
          end;
          call lock (universe.lock);
          universe.holes = universe.holes + 1;
          universe.black_hole (universe.holes) = new_hole;
          call unlock (universe.lock);
          do x = 1 to universe.number;
               edir = universe.pdir (x);
               call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
               if enemy ^= null () then do;
                         call lock (enemy -> ship.lock);
                         enemy -> ship.black_hole = new_hole;
                         call unlock (enemy -> ship.lock);
                    end;
          end;
          
     end rand_new_hole;
     
pulling_damage: procedure;

          call lock (my -> ship.lock);
          my -> ship.energy_cur = max (0, my -> ship.energy_cur - 100);
          my -> ship.energy_old = max (0, my -> ship.energy_old - 100);
          my -> ship.life_cur = max (0, my -> ship.life_cur - 3);
          my -> ship.life_old = max (0, my -> ship.life_old - 3);
          my -> ship.shields_cur = max (0, my -> ship.shields_cur - 10);
          my -> ship.shields_old = max (0, my -> ship.shields_old - 10);
          call unlock (my -> ship.lock);
          call ioa_ ("^/*** ENGINEERING: Sir, our engines have taken heavy damages!");
          call ioa_ ("*** MEDICAL: Sir, heavy casualties reported in all stations!");
          call ioa_ ("*** CONTROL: Sir, our shields have taken heavy damages!");
          
     end pulling_damage;
     
suck_him_in: procedure;

          dcl     hole_here              bit (1) init ("0"b);
          dcl     x                      fixed bin int (0);
          
          do x = 1 to universe.holes;
               if universe.black_hole (x) = my -> ship.location then hole_here = "1"b;
          end;
          if hole_here = "0"b then return;
          x = mod (clock (), 500) + 1;
          if x > my -> ship.energy_cur then do;
                    call ioa_ ("^/BLACK HOLE is pulling our ship in, sir!");
                    call ioa_ ("^/IMPULSE engines activated, sir");
                    do x = 1 to 1000000;
                    end;
                    x = mod (clock (), 4) + 1;
                    if x > 1 then call game_over;
                    call ioa_ ("ESCAPE successful, sir");
               end;
               
     end suck_him_in;
     
     end black_hole_check;

/***** ROBOT INTERNALS *****/

robot_sscan: procedure (present, shipname, shiptype, docked);

          dcl     present                fixed bin parm;
          dcl     shipname               (*) char (*) parm;
          dcl     shiptype               (*) char (*) parm;
          dcl     docked                 (*) char (*) parm;
          dcl     x                      fixed bin init (0);
          
          do x = 1 to 20;
               if my -> ship.location = universe.robot (x).location then do;
                         present = present + 1
                         shipname (present) = universe.robot (x).name;
                         shiptype (present) = "RobotShip";
                         if universe.robot (x).condition = "DOCKING" then docked (present) = "(Docking)";
                    end;
          end;
          
     end robot_sscan;
     
robot_verify_target: procedure (target, is_he_there);

          dcl     target                 char (*) parm;
          dcl     is_he_there            bit (1) parm;
          dcl     x                      fixed bin init (0);
          
          do x = 1 to 20;
               if (my -> ship.location = universe.robot (x).location) & (target = universe.robot (x).name) then is_he_there = "1"b;
          end;
          
     end robot_verify_target;
     
robot_hit_him: procedure (target, robot_was_the_target, weapon, hit);

          dcl     target                 char (*) parm;
          dcl     robot_was_the_target   bit (1) parm;
          dcl     weapon                 char (*) parm;
          dcl     hit                    bit (1) parm;
          
          if target_is_a_robot (target) then robot_was_the_target = "1"b;
          if weapon ^= "missile" then x = mod (clock (), 1601) + 400;
          else x = mod (clock (), 1600) + 1;
          if (x > 1538 & weapon = "lasers") | (x > 1923 & weapon = "missile") then do;
                    call ioa_ ("^/<<< BOOOOOOOOOOM >>>");
                    call ioa_ ("<<< BOOOOOOOOOOM >>>");
                    call ioa_ ("^/CRITICAL centers have been hit on the RobotShip ^a!", target);
                    call robot_death (target);
                    target = "critical";
                    return;
               end;
          else if x > universe.robot (robot_index (target)).energy then hit = "1"b;
          else hit = "0"b;
          
     end robot_hit_him;
     
robot_damage: procedure (target, x);

          dcl     target                 char (*) parm;
          dcl     x                      fixed bin parm;
          
          if ^target_is_a_robot (target) then return;
          if universe.robot (robot_index (target)).condition = "DOCKING" then do;
                    call robot_death (target);
                    call ioa_ ("^/FORCE FIELDS were down on the RobotShip ^a, sir", target);
                    x = 666;
                    return;
               end;
          x = mod (clock (), 100) + 1;
          call lock (universe.lock);
          universe.robot (robot_index (target)).energy = max (universe.robot (robot_index (target)).energy - x, 0);
          call unlock (universe.lock);
          call ioa_ ("^/ENERGY reduced on the RobotShip ^a", target);
          if universe.robot (robot_index (target)).energy = 0 then call robot_death (target);
          x = 666;
          
     end robot_damage;
     
robot_death: procedure (target);

          dcl     target                 char (*) parm;
          dcl     x                      fixed bin init (0);
          
          do x = 1 to universe.number;
               edir = universe.pdir (x);
               call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
               if enemy ^= null () & enemy -> ship.name ^= "" & enemy -> ship.type ^= "" then do;
                         call lock (enemy -> ship.lock);
                         enemy -> ship.deathmes = "dead";
                         enemy -> ship.deadname = universe.robot (robot_index (target)).name;
                         enemy -> ship.deadtype = "RobotShip";
                         call unlock (enemy -> ship.lock);
                    end;
          end;
          call lock (universe.lock);
          universe.robot (robot_index (target)).location = "";
          universe.robot (robot_index (target)).controller = "dead";
          call unlock (universe.lock);
          
     end robot_death;
     
robot_release: procedure (control);

          dcl     control                char (*) parm;
          dcl     x                      fixed bin init (0);
          
          do x = 1 to 20;
               if universe.robot (x).controller = control then do;
                         call lock (universe.lock);
                         universe.robot (x).controller = "free";
                         call unlock (universe.lock);
                    end;
          end;
          
     end robot_release;
     
target_is_a_robot: procedure (target) returns (bit (1));

          dcl     target                 char (*) parm;
          
          if substr (target, 1, 2) = "R\" then return ("1"b);
          return ("0"b);
          
     end target_is_a_robot;
     
robot_index: procedure (target) returns (fixed bin);

          dcl     target                 char (*) parm;
          dcl     x                      fixed bin init (0);
          
          do x = 1 to 20;
               if universe.robot (x).name = target then return (x);
          end;
          return (0);
          
     end robot_index;
     
robot_num: procedure returns (fixed bin);

          dcl     x                      fixed bin init (0);
          dcl     count                  fixed bin init (0);
          
          do x = 1 to 20;
               if universe.robot (x).controller ^= "none" & universe.robot (x).controller ^= "dead" then count = count + 1;
          end;
          return (count);
          
     end robot_num;
     
/***** ROBOT CONTROL FUNCTIONS *****/

robot_functions: procedure;

          if my -> ship.condition ^= "DOCKING" then do;
                    call rand_new_robot;
                    call take_free_robot;
               end;
          call hack_robot_actions;
          
rand_new_robot: procedure;

          dcl     dead_count             fixed bin init (0);
          dcl     x                      fixed bin init (0);
          
          x = mod (clock (), max (robot_num () * 200, 1)) + 1;
          if x > 1 then return;
          do x = 1 to 20;
               if universe.robot (x).controller = "none" then do;
                         call lock (universe.lock);
                         universe.robot (x).energy = 1000;
                         universe.robot (x).location = rand_location ();
                         universe.robot (x).controller = my -> ship.user;
                         call unlock (universe.lock);
                         return;
                    end;
               if universe.robot (x).controller = "dead" then dead_count = dead_count + 1;
          end;
          if dead_count < 20 then return;
          call lock (universe.lock);
          universe.robot (*).controller = "none";
          call unlock (universe.lock);
          
     end rand_new_robot;
     
take_free_robot: procedure;

          dcl     x                      fixed bin init (0);
          
          do x = 1 to 20;
               if universe.robot (x).controller = "free" then do;
                         call lock (universe.lock);
                         universe.robot (x).controller = my -> ship.user;
                         call unlock (universe.lock);
                    end;
          end;
          
     end take_free_robot;
     
hack_robot_actions: procedure;

          dcl     ROBOT                  char (5) init ("");
          dcl     action                 char (4) init ("");
          dcl     x                      fixed bin init (0);
          
          if my -> ship.condition = "DOCKING" then do;
                    x = mod (clock (), 100000) + 1;
                    if x > 1 then return;
               end;
          do x = 1 to 20;
               if universe.robot (x).controller = my -> ship.user then do;
                         ROBOT = universe.robot (x).name;
                         call look_for_targets (action);
                         if action = "" then call health_check (action);
                         if action = "" then call move_or_contact (action);
                         if action = "fire" then call robot_fire;
                         if action = "move" then call robot_move;
                         if action = "cont" then call robot_send_msg;
                    end;
          end;
          
look_for_targets: procedure (action);

          dcl     action                 char (*) parm;
          dcl     x                      fixed bin init (0);
          
          if universe.robot (robot_index (ROBOT)).condition = "DOCKING" then return;
          do x = 1 to universe.number;
               edir = universe.pdir (x);
               call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
               if enemy ^= null () & enemy -> ship.location = universe.robot (robot_index (ROBOT)).location then do;
                         action = "fire";
                         return;
                    end;
          end;
          
     end look_for_targets;
     
health_check: procedure (action);

          dcl     action                 char (*) parm;
          
          if universe.robot (robot_index (ROBOT)).energy < 200 then action = "dock";
          else if universe.robot (robot_index (ROBOT)).condition = "DOCKING" then action = "dock";
          
     end health_check;
     
move_or_contact: procedure (action);

          dcl     action                 char (*) parm;
          dcl     x                      fixed bin init (0);
          
          x = mod (clock (), 10) + 1;
          if x < 3 then return;
          else if x = 3 then action = "cont";
          else action = "move";
          
     end move_or_contact;
     
robot_fire: procedure;

          dcl     count                  fixed bin init (0);
          dcl     tptr                   (10) ptr init ((10) (null ()));
          dcl     x                      fixed bin init (0);
          dcl     who                    fixed bin init (0);
          dcl     hit                    bit (1) init ("0"b);
          
count_enemies:
          do x = 1 to universe.number;
               edir = universe.pdir (x);
               call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
               if enemy ^= null () & enemy -> ship.location = universe.robot (robot_index (ROBOT)).location then do;
                         count = count + 1;
                         tptr (count) = enemy;
                    end;
          end;
          if count = 0 then return;
          who = mod (clock (), count) + 1;
          enemy = tptr (who);
          if enemy = null () then goto count_enemies;
          target = "";
          call lock (my -> ship.lock);
          if my -> ship.condition = "D-RAY" | my -> ship.condition = "DOCKING" then my -> ship.condition = "DROBOT";
          else my -> ship.condition = "ROBOT";
          call unlock (my -> ship.lock);
          on seg_fault_error call ignore_signal_2;
          call hit_that_sucker (hit, "plasma");
          if hit then call inflict_damage;
          call lock (universe.lock);
          universe.robot (robot_index (ROBOT)).energy = max (0, universe.robot (robot_index (ROBOT)).energy - 10);
          call unlock (universe.lock);
          on seg_fault_error call universe_destroyed;
          call update_condition;
          
ignore_signal_2: procedure;

/* PROCEDURE FOR IGNORIG SEG_FAULT_ERRORS DURING ROBOT ATTACKS */

          goto command_loop;
          
     end ignore_signal_2;
     
     end robot_fire;
     
robot_dock: procedure;

          dcl     x                      fixed bin init (0);
          
          if universe.robot (robot_index (ROBOT)).condition = "DOCKING" then do;
                    x = mod (clock (), 3) + 1;
                    if x = 1 then do;
                              call lock (universe.lock);
                              universe.robot (robot_index (ROBOT)).condition = "";
                              call unlock (universe.lock);
                         end;
                    return;
               end;
          x = mod (clock (), 100) + 1;
          call lock (universe.lock);
          universe.robot (robot_index (ROBOT)).energy = min (0, universe.robot (robot_index (ROBOT)).energy + x);
          universe.robot (robot_index (ROBOT)).condition = "DOCKING";
          call unlock (universe.lock);
          
     end robot_dock;
     
robot_move: procedure;

          dcl     open_sectors           (2) char (8) init ((2) (""));
          dcl     x                      fixed bin init (0);
          
          if universe.robot (robot_index (ROBOT)).location = "Romula" then do;
                    open_sectors (1) = "Vindicar";
                    x = 1;
               end;
          else if universe.robot (robot_index (ROBOT)).location = "Vindicar" then do;
                    open_sectors (1) = "Romula";
                    open_sectors (2) = "Telgar";
          else if universe.robot (robot_index (ROBOT)).location = "Telgar" then do;
                    open_sectors (1) = "Vindicar";
                    open_sectors (2) = "Shadow";
          else if universe.robot (robot_index (ROBOT)).location = "Shadow" then do;
                    open_sectors (1) = "Telgar";
                    open_sectors (2) = "Zork";
          else do;
                    open_sectors (1) = "Shadow";
                    z = 1;
               end;
          if x ^= 1 then x = mod (clock (), 2) + 1;
          call lock (universe.lock);
          universe.robot (robot_index (ROBOT)).location = open_sectors (x);
          call unlock (universe.lock);
          
     end robot_move;
     
robot_send_msg: procedure;

          dcl     x                      fixed bin init (0);
          dcl     count                  fixed bin init (0);
          dcl     which                  fixed bin init (0);
          dcl     msg                    char (256) init ("");
          dcl     msg_file               file;
          dcl     sysin                  file;
          
          open file (msg_file) title ("vfile_ " || dname || ">" || "sv4.4.text") stream input;
          read file (msg_file) into (msg);
          count = decimal (msg);
          which = mod (clock (), count) + 1;
          do x = 1 to which;
               read file (msg_file) into (msg);
          end;
          close file (msg_file);
          which = mod (clock (), universe.number) + 1;
          do x = 1 to which;
               edir = universe.pdir (x);
               call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
               if enemy ^= null () & x = which then do;
                         call lock (enemy -> ship.lock);
                         enemy -> ship.fromtype = "RobotShip";
                         enemy -> ship.fromname = ROBOT;
                         enemy -> ship.message = msg;
                         call unlock (enemy -> ship.lock);
                    end;
          end;
          
     end robot_snd_msg;
     
     end hack_robot_actions;
     
     end robot_functions;

/***** GAME INTERNALS *****/

make_ship: procedure (shiptype);

          dcl     shiptype               char (14) parm;
          
          call lock (my -> ship.lock);
          my -> ship.type = shiptype;
          my -> ship.life_cur, my -> ship.life_old = 10;
          my -> ship.condition = "GREEN";
          if shiptype = "Destroyer" then do;
                    my -> ship.energy_cur, my -> ship.energy_old, my -> ship.energy_max = 700;
                    my -> ship.shields_cur, my -> ship.shields_old, my -> ship.shields_max = 50;
                    my -> ship.torps_cur, my -> ship.torps_old, my -> ship.torps_max = 10;
               end;
          else if shiptype = "Cruiser" then do;
                    my -> ship.energy_cur, my -> ship.energy_old, my -> ship.energy_max = 800;
                    my -> ship.shields_cur, my -> ship.shields_old, my -> ship.shields_max = 70;
                    my -> ship.torps_cur, my -> ship.torps_old, my -> ship.torps_max = 5;
               end;
          else if shiptype = "Starship" then do;
                    my -> ship.energy_cur, my -> ship.energy_old, my -> ship.energy_max = 1000;
                    my -> ship.shields_cur, my -> ship.shields_old, my -> ship.shields_max = 60;
                    my -> ship.torps_cur, my -> ship.torps_old, my -> ship.torps_max = 5;
               end;
          else if shiptype = "Star Commander" then do;
                    my -> ship.energy_cur, my -> ship.energy_old, my -> ship.energy_max = 100000;
                    my -> ship.shields_cur, my -> ship.shields_old, my -> ship.shields_max = 1000;
                    my -> ship.torps_cur, my -> ship.torps_old, my -> ship.torps_max = 100;
               end;
          my -> ship.location = rand_location ();
          call unlock (my -> ship.lock);
          
     end make_ship;
     
update_condition: procedure;

          on quit call command_seq_terminator;
          call term_$single_refname ((DO), code);
          call hcs_$initiate (DO_dir, DO, DO, 0, 0, (null ()), code);
          call set_acl (entry, acl, whom);
          call set_acl (entry, acl, rtrim (person) || "." || project);
          call lock (my -> ship.lock);
          if my -> ship.life_cur = 0 then call game_over;
          else if my -> ship.deathmes = "down" then call game_over;
          else if my -> ship.shields_cur = 0 then my -> ship.condition = "SHIELDS_DOWN";
          else if my -> ship.condition = "DROBOT" then my -> ship.condition = "D-RAY";
          else if my -> ship.life_cur > 6 then my -> ship.condition = "GREEN";
          else if my -> ship.life_cur > 2 then my -> ship.condition = "YELLOW";
          else my -> ship.condition = "RED";
          call unlock (my -> ship.lock);
          
/* ELIMINATE GHOST SHIPS */
          do x = 1 to universe.number;
               edir = universe.pdir (x);
               call hcs_$initiate (edir, ename, "", 0, 0, enemy, code);
               if enemy ^= null () then do;
                         do y = 1 to universe.number;
                              if universe.user (x) = enemy -> ship.user & universe.unique_id (x) ^= enemy -> ship.unique_id then do;
                                        call lock (universe.lock);
                                        do z = y to universe.number;
                                             universe.pdir (z) = universe.pdir (z + 1);
                                             universe.user (z) = universe.user (z + 1);
                                             universe.unique_id (z) = universe.unique_id (z + 1);
                                        end;
                                        universe.pdir (universe.number) = "";
                                        universe.user (universe.number) = "";
                                        universe.number = universe.number - 1;
                                        call unlock (universe.lock);
                                   end;
                         end;
                    end;
          end;
          
     end update_condition;
     
security_check: procedure;

          if my -> ship.type = "Star Commander" & (access = "no" | shiptype ^= my -> ship.type) then do;
                    call ioa_ ("^/FROM STARFLEET COMMAND: You have unathorized control of a Star Commander.^/You will be destroyed...");
                    call game_over;
               end;
               
     end security_check;
     
timed_input: procedure (input);

          dcl     input                  char (*) varying parm;
          dcl     ten                    fixed bin (71) int static init (10);
          dcl     seconds                bit (2) int static init ("11"b);
          
          call timer_manager_$alarm_call (ten, seconds, inform_routines);
          call security_check;
          call getline (input);
          call timer_manager_$reset_alarm_call (inform_routines);
          return;
          
inform_routines: entry;

          on seg_fault_error call universe_destroyed;
          call damage_check;
          call message_check;
          call death_check;
          call black_hole_check;
          call check_monitor;
          call psionics_check;
          call robot_functions;
          call timer_manager_$alarm_call (ten, seconds, inform_routines);
          return;
          
     end timed_input;

command_seq_terminator: procedure;

          call ioa_ ("^/:: COMMAND SEQUENCE TERMINATED ::");
          goto command_loop;
          
     end command_seq_terminator;
     
send_notifications: procedure;

          dcl     send_mail_             entry (char (*), char (*), ptr, fixed bin (35));
          
          send_mail_info.sent_from = "STARRUNNERS";
          send_mail_info.version = send_mail_info_version_2;
          send_mail_info.wakeup = "1"b;
          send_mail_info.acknowledge = "0"b;
          send_mail_info.notify = "0"b;
          send_mail_info.always_add = "0"b;
          send_mail_info.never_add = "0"b;
          do x = 1 to 50;
               if universe.notifications (x).person_id ^= "" & universe.notifications (x).project_id ^= "" then do;
                         call send_mail_ ((rtrim (universe.notifications (x).person_id) || "." || rtrim (universe.notifications (x).project_id)), "I have just entered the Starrunners universe...", addr (send_mail_info), (0));
                    end;
          end;
          
     end send_notifications;

rand_location: procedure returns (char (8));

          dcl     location               char (8) init ("");
          dcl     x                      fixed bin init (0);
          
          x = mod (clock (), 5) + 1;
          if x = 1 then location = "Romula";
          else if x = 2 then location = "Vindicar";
          else if x = 3 then location = "Telgar";
          else if x = 4 then location = "Shadow";
          else location = "Zork";
          return (location);
          
     end rand_location;

generate_codeword: procedure (key_word) returns (char (10));

          dcl     key_word               char (*) parm;
          dcl     password               char (10) init ("");
          dcl     new_pass               char (10) varying init ("");
          dcl     (idx, shift, position, new_pos) fixed bin init (0);
          dcl     ALPHA_1                char (26) init ("abcdefghijklmnopqrstuvwxyz");
          dcl     ALPHA_2                char (26) init ("zafkpubglqvchmrwdinsxejoty");
          
          password = key_word;
          do x = 1 to 3;
               do y = 1 to length (rtrim (password));
                    if y = length (rtrim (password)) then idx = 0;
                    else idx = y;
                    shift = index (ALPHA_1, substr (password, idx + 1, 1));
                    position = index (ALPHA_2, substr (password, y, 1));
                    new_pos = shift + position;
                    if new_pos > 26 then new_pos = new_pos - 26;
                    new_pass = new_pass || substr (ALPHA_2, new_pos, 1);
               end;
               password = new_pass;
               new_pass = "";
          end;
          return (password);
          
     end generate_codeword;
     
lock: procedure (lock_bit);

          dcl     set_lock_$lock         entry (bit (36) aligned, fixed bin, fixed bin (35));
          dcl     lock_bit               bit (36) aligned parm;
          dcl     code                   fixed bin (35) init (0);
          
          call set_lock_$lock (lock_bit, 5, code);
          
     end lock;
     
unlock: procedure (lock_bit);

          dcl     set_lock_$unlock       entry (bit (36) aligned, fixed bin (35));
          dcl     lock_bit               bit (36) aligned parm;
          dcl     code                   fixed bin (35) init (0);
          
          call set_lock_$unlock (lock_bit, code);
          
     end unlock;
     

/***** STAR ADMIN SYSTEM *****/

star_admin: procedure;

          dcl       password             char (10) init ("");
          dcl       MAIN                 char (10) init ("star_admin");
          dcl       version              char (5) init ("1.2");
          dcl       date                 builtin;
          
          input = "";
          call ioa_ ("^/Star Admin ^a^/", version);
          call read_password_ ("Password:", password);
          if password ^= ltrim (char (date)) then do;
                    call ioa_ ("^a: Incorrect password supplied.", MAIN);
                    return;
               end;
          password = "";
          do while ("1"b);
               call ioa_$nnl ("^/Star admin: ");
               call getline (input);
               if input = "big-bang" | input = "bb" then call big_bang;
               else if input = "set-pswd" | input = "sp" then call set_password;
               else if input = "remove-pswd" | input = "rp" then call remove_password;
               else if input = "add-starcom" | input = "as" then call add_star_commander;
               else if input = "remove-starcom" | input = "rs" then call remove_star_commander;
               else if input = "generate-code" | input = "gc" then call generate_password;
               else if input = "quit" | input = "q" then return;
               else if input = "." then call ioa_ ("^/^a ^a", MAIN, version);
               else if input = "?" then do;
                         call ioa_ ("^/Star Admin commands:");
                         call ioa_ ("   (bb) big-bang ---------- Destroy the universe");
                         call ioa_ ("   (sp) set-pswd ---------- Set a game password");
                         call ioa_ ("   (rp) remove-pswd ------- Remove the game password");
                         call ioa_ ("   (as) add-starcom ------- Add a Person_ID as a Star Commander");
                         call ioa_ ("   (rs) remove-starcom ---- Remove a Person_ID as a Star Commander");
                         call ioa_ ("   (gc) generate-code ----- Generate a codeword");
                         call ioa_ ("    (q) quit -------------- Quit the star admin system");
                    end;
               else if input ^= "" then call ioa_ ("^a: That is not a standard request:^/^12xType a ""?"" for a list of proper requests.", MAIN);
          end;
          
/* STAR ADMIN REQUEST ROUTINES */

big_bang: procedure;

          call hcs_$initiate (dname, xname, "", 0, 0, univptr, code);
          if code ^= 0 & univptr = null () then do;
                    call ioa_ ("^a (big_bang): No database was found.", MAIN);
                    call ioa_ ("Creating ^a>^a", dname, xname);
                    call hcs_$make_seg (dname, xname, "", (10), univptr, code);
                    universe.number, universe.holes, universe.unique_id = 0;
                    universe.pdir, universe.black_hole, universe.password, universe.user = "";
               end;
          else do;
                    call ioa_ ("^a (big_bang): Database destroyed and re-created.", MAIN);
                    call hcs_$delentry_seg (dname, xname, "", (10), univptr, code);
                    call hcs_$make_seg (dname, xname, "", (10), univptr, code);
                    universe.number, universe.holes, universe.unique_id = 0;
                    universe.pdir, universe.black_hole, universe.password, universe.user = "";
               end;
          call hcs_$initiate (dname, aname, "", 0, 0, adminptr, code);
          if code ^= 0 & adminptr = null () then do;
                    call create_database;
                    call ioa_ ("^/Created: ^a>^a", dname, aname);
               end;
          else do;
                    call hcs_$delentry_seg (adminptr, code);
                    call create_database;
               end;
               
create_database: procedure;

          dcl     acl                   char (1) init ("r");
          dcl     whom                  char (5) init ("*.*.*");
          
          call hcs_$make_seg (dname, aname, "", (10), adminptr, code);
          call set_acl (rtrim (dname) || ">" || aname, acl, whom);
          call ioa_$nnl ("^a (admin_info): Game Admin: ", MAIN);
          call getline (input);
          admin_info.game_admin = input;
          call ioa_$nnl ("^a (admin_info): User_info_line: ", MAIN);
          call getline (input);
          admin_info.user_info_line = input;
          call ioa_$nnl ("^a (admin_info): Command_query_line: ", MAIN);
          call getline (input);
          admin_info.com_query_line = input;
          admin_info.star_comn = 1;
          call ioa_$nnl ("^a (admin_info): Star Commander: ", MAIN);
          call getline (input);
          admin_info.star_coms (1) = input;
          
     end create_database;
     
     end big_bang;

set_password: procedure;

          call hcs_$initiate (dname, xname, "", 0, 0, univptr, code);
          if code ^= 0 & univptr = null () then do;
                    call ioa_ ("^a (set_pswd): Database not found. ^a>^a", MAIN, dname, xname);
                    return;
               end;
          input = "#";
          do while (input = "#");
               call ioa_$nnl ("^/New password: ");
               call getline (input);
               if input = "" then do;
                         call ioa_ ("^a (set_pswd): Current password ""^a"" not changed.", MAIN, universe.password);
                         return;
                    end;
               if verify (input, allowed_chars) = 0 then password = input;
               else do;
                         call ioa_ ("^a (set_pswd): Invalid character(s) found in pssword.  Please retype.", MAIN);
                         input = "#";
                    end;
               universe.password = password;
          end;
          
     end set_password;
     
remove_password: procedure;

          call hcs_$initiate (dname, xname, "", 0, 0, univptr, code);
          if code ^= 0 & univptr = null () then do;
                    call ioa_ ("^a (remove_pswd): Database not found. ^a>^a", MAIN, dname, xname);
                    return;
               end;
          universe.password = "";
          call ioa_ ("^a (remove_pswd): Password removed.", MAIN);
          
     end remove_password;
     
generate_password: procedure;

          dcl     codeword               char (10) init ("");
          dcl     input                  char (10) varying init ("");
          
          call ioa_$nnl ("^/Keyword: ");
          call getline (input);
          if input = "" then return;
          codeword = input;
          call ioa_ ("^/Codeword is ""^a"".", generate_codeword (codeword));
          
     end generate_password;

add_star_commander: procedure;

          call hcs_$initiate (dname, aname, "", 0, 0, adminptr, code);
          if code ^= 0 & adminptr = null () then do;
                    call ioa_ ("^a (add_starcom): Database not found. ^a>^a", MAIN, dname, aname);
                    return;
               end;
          call ioa_$nnl ("^a (add_starcom): Person ID: ", MAIN);
          call getline (input);
          if input = "" then return;
          do x = 1 to admin_info.star_comn;
               if admin_info.star_coms (x) = "" then do;
                         admin_info.star_coms (x) = input;
                         return;
                    end;
          end;
          admin_info.star_comn = admin_info.star_comn + 1;
          admin_info.star_coms (admin_info.star_comn) = input;
          
     end add_star_commander;
     
remove_star_commander: procedure;

          call hcs_$initiate (dname, aname, "", 0, 0, adminptr, code);
          if code ^= 0 & adminptr = null () then do;
                    call ioa_ ("^a (remove_starcom): Database not found. ^a>^a", MAIN, dname, aname);
                    return;
               end;
          call ioa_ ("^/Current Star Commanders:");
          do x = 1 to admin_info.star_comn;
               if admin_info.star_coms (x) ^= "" then call ioa_ ("   ^a", admin_info.star_coms (x));
          end;
          call ioa_$nnl ("^a (remove_starcom): Person ID: ", MAIN);
          call getline (input);
          if input = "" then return;
          do x = 1 to admin_info.star_comn;
               if admin_info.star_coms (x) = input then admin_info.star_coms (x) = "";
          end;
          
     end remove_star_commander;

getline: procedure (input_var);

          dcl     input_var              char (*) varying parm;
          dcl     MAIN                   char (11) init ("starrunners");
          dcl     command_query_         entry options (variable);
          
          query_info.version = query_info_version_5;
          query_info.suppress_spacing = "1"b;
          query_info.suppress_name_sw = "1"b;
          query_info.cp_escape_control = "10"b;
          
          call command_query_ (addr (query_info), input_var, MAIN);
          
%include query_info;

     end getline;
     